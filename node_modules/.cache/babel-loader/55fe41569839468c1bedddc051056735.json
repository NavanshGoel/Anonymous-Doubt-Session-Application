{"ast":null,"code":"'use strict';\n\nconst net = require('net');\n\nclass TimeoutError extends Error {\n  constructor(threshold, event) {\n    super(`Timeout awaiting '${event}' for ${threshold}ms`);\n    this.name = 'TimeoutError';\n    this.code = 'ETIMEDOUT';\n    this.event = event;\n  }\n\n}\n\nconst reentry = Symbol('reentry');\n\nconst noop = () => {};\n\nmodule.exports = (request, delays, options) => {\n  /* istanbul ignore next: this makes sure timed-out isn't called twice */\n  if (request[reentry]) {\n    return;\n  }\n\n  request[reentry] = true;\n  let stopNewTimeouts = false;\n\n  const addTimeout = (delay, callback, ...args) => {\n    // An error had been thrown before. Going further would result in uncaught errors.\n    // See https://github.com/sindresorhus/got/issues/631#issuecomment-435675051\n    if (stopNewTimeouts) {\n      return noop;\n    } // Event loop order is timers, poll, immediates.\n    // The timed event may emit during the current tick poll phase, so\n    // defer calling the handler until the poll phase completes.\n\n\n    let immediate;\n    const timeout = setTimeout(() => {\n      immediate = setImmediate(callback, delay, ...args);\n      /* istanbul ignore next: added in node v9.7.0 */\n\n      if (immediate.unref) {\n        immediate.unref();\n      }\n    }, delay);\n    /* istanbul ignore next: in order to support electron renderer */\n\n    if (timeout.unref) {\n      timeout.unref();\n    }\n\n    const cancel = () => {\n      clearTimeout(timeout);\n      clearImmediate(immediate);\n    };\n\n    cancelers.push(cancel);\n    return cancel;\n  };\n\n  const {\n    host,\n    hostname\n  } = options;\n\n  const timeoutHandler = (delay, event) => {\n    request.emit('error', new TimeoutError(delay, event));\n    request.once('error', () => {}); // Ignore the `socket hung up` error made by request.abort()\n\n    request.abort();\n  };\n\n  const cancelers = [];\n\n  const cancelTimeouts = () => {\n    stopNewTimeouts = true;\n    cancelers.forEach(cancelTimeout => cancelTimeout());\n  };\n\n  request.once('error', cancelTimeouts);\n  request.once('response', response => {\n    response.once('end', cancelTimeouts);\n  });\n\n  if (delays.request !== undefined) {\n    addTimeout(delays.request, timeoutHandler, 'request');\n  }\n\n  if (delays.socket !== undefined) {\n    const socketTimeoutHandler = () => {\n      timeoutHandler(delays.socket, 'socket');\n    };\n\n    request.setTimeout(delays.socket, socketTimeoutHandler); // `request.setTimeout(0)` causes a memory leak.\n    // We can just remove the listener and forget about the timer - it's unreffed.\n    // See https://github.com/sindresorhus/got/issues/690\n\n    cancelers.push(() => request.removeListener('timeout', socketTimeoutHandler));\n  }\n\n  if (delays.lookup !== undefined && !request.socketPath && !net.isIP(hostname || host)) {\n    request.once('socket', socket => {\n      /* istanbul ignore next: hard to test */\n      if (socket.connecting) {\n        const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n        socket.once('lookup', cancelTimeout);\n      }\n    });\n  }\n\n  if (delays.connect !== undefined) {\n    request.once('socket', socket => {\n      /* istanbul ignore next: hard to test */\n      if (socket.connecting) {\n        const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n\n        if (request.socketPath || net.isIP(hostname || host)) {\n          socket.once('connect', timeConnect());\n        } else {\n          socket.once('lookup', error => {\n            if (error === null) {\n              socket.once('connect', timeConnect());\n            }\n          });\n        }\n      }\n    });\n  }\n\n  if (delays.secureConnect !== undefined && options.protocol === 'https:') {\n    request.once('socket', socket => {\n      /* istanbul ignore next: hard to test */\n      if (socket.connecting) {\n        socket.once('connect', () => {\n          const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n          socket.once('secureConnect', cancelTimeout);\n        });\n      }\n    });\n  }\n\n  if (delays.send !== undefined) {\n    request.once('socket', socket => {\n      const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n      /* istanbul ignore next: hard to test */\n\n\n      if (socket.connecting) {\n        socket.once('connect', () => {\n          request.once('upload-complete', timeRequest());\n        });\n      } else {\n        request.once('upload-complete', timeRequest());\n      }\n    });\n  }\n\n  if (delays.response !== undefined) {\n    request.once('upload-complete', () => {\n      const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n      request.once('response', cancelTimeout);\n    });\n  }\n};\n\nmodule.exports.TimeoutError = TimeoutError;","map":{"version":3,"sources":["/Users/kanavmittal/Downloads/Anonymous-Doubt-Session-Application-Ashank-App/node_modules/got/source/utils/timed-out.js"],"names":["net","require","TimeoutError","Error","constructor","threshold","event","name","code","reentry","Symbol","noop","module","exports","request","delays","options","stopNewTimeouts","addTimeout","delay","callback","args","immediate","timeout","setTimeout","setImmediate","unref","cancel","clearTimeout","clearImmediate","cancelers","push","host","hostname","timeoutHandler","emit","once","abort","cancelTimeouts","forEach","cancelTimeout","response","undefined","socket","socketTimeoutHandler","removeListener","lookup","socketPath","isIP","connecting","connect","timeConnect","error","secureConnect","protocol","send","timeRequest"],"mappings":"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","sourcesContent":["'use strict';\nconst net = require('net');\n\nclass TimeoutError extends Error {\n\tconstructor(threshold, event) {\n\t\tsuper(`Timeout awaiting '${event}' for ${threshold}ms`);\n\t\tthis.name = 'TimeoutError';\n\t\tthis.code = 'ETIMEDOUT';\n\t\tthis.event = event;\n\t}\n}\n\nconst reentry = Symbol('reentry');\n\nconst noop = () => {};\n\nmodule.exports = (request, delays, options) => {\n\t/* istanbul ignore next: this makes sure timed-out isn't called twice */\n\tif (request[reentry]) {\n\t\treturn;\n\t}\n\n\trequest[reentry] = true;\n\n\tlet stopNewTimeouts = false;\n\n\tconst addTimeout = (delay, callback, ...args) => {\n\t\t// An error had been thrown before. Going further would result in uncaught errors.\n\t\t// See https://github.com/sindresorhus/got/issues/631#issuecomment-435675051\n\t\tif (stopNewTimeouts) {\n\t\t\treturn noop;\n\t\t}\n\n\t\t// Event loop order is timers, poll, immediates.\n\t\t// The timed event may emit during the current tick poll phase, so\n\t\t// defer calling the handler until the poll phase completes.\n\t\tlet immediate;\n\t\tconst timeout = setTimeout(() => {\n\t\t\timmediate = setImmediate(callback, delay, ...args);\n\t\t\t/* istanbul ignore next: added in node v9.7.0 */\n\t\t\tif (immediate.unref) {\n\t\t\t\timmediate.unref();\n\t\t\t}\n\t\t}, delay);\n\n\t\t/* istanbul ignore next: in order to support electron renderer */\n\t\tif (timeout.unref) {\n\t\t\ttimeout.unref();\n\t\t}\n\n\t\tconst cancel = () => {\n\t\t\tclearTimeout(timeout);\n\t\t\tclearImmediate(immediate);\n\t\t};\n\n\t\tcancelers.push(cancel);\n\n\t\treturn cancel;\n\t};\n\n\tconst {host, hostname} = options;\n\tconst timeoutHandler = (delay, event) => {\n\t\trequest.emit('error', new TimeoutError(delay, event));\n\t\trequest.once('error', () => {}); // Ignore the `socket hung up` error made by request.abort()\n\n\t\trequest.abort();\n\t};\n\n\tconst cancelers = [];\n\tconst cancelTimeouts = () => {\n\t\tstopNewTimeouts = true;\n\t\tcancelers.forEach(cancelTimeout => cancelTimeout());\n\t};\n\n\trequest.once('error', cancelTimeouts);\n\trequest.once('response', response => {\n\t\tresponse.once('end', cancelTimeouts);\n\t});\n\n\tif (delays.request !== undefined) {\n\t\taddTimeout(delays.request, timeoutHandler, 'request');\n\t}\n\n\tif (delays.socket !== undefined) {\n\t\tconst socketTimeoutHandler = () => {\n\t\t\ttimeoutHandler(delays.socket, 'socket');\n\t\t};\n\n\t\trequest.setTimeout(delays.socket, socketTimeoutHandler);\n\n\t\t// `request.setTimeout(0)` causes a memory leak.\n\t\t// We can just remove the listener and forget about the timer - it's unreffed.\n\t\t// See https://github.com/sindresorhus/got/issues/690\n\t\tcancelers.push(() => request.removeListener('timeout', socketTimeoutHandler));\n\t}\n\n\tif (delays.lookup !== undefined && !request.socketPath && !net.isIP(hostname || host)) {\n\t\trequest.once('socket', socket => {\n\t\t\t/* istanbul ignore next: hard to test */\n\t\t\tif (socket.connecting) {\n\t\t\t\tconst cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n\t\t\t\tsocket.once('lookup', cancelTimeout);\n\t\t\t}\n\t\t});\n\t}\n\n\tif (delays.connect !== undefined) {\n\t\trequest.once('socket', socket => {\n\t\t\t/* istanbul ignore next: hard to test */\n\t\t\tif (socket.connecting) {\n\t\t\t\tconst timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n\n\t\t\t\tif (request.socketPath || net.isIP(hostname || host)) {\n\t\t\t\t\tsocket.once('connect', timeConnect());\n\t\t\t\t} else {\n\t\t\t\t\tsocket.once('lookup', error => {\n\t\t\t\t\t\tif (error === null) {\n\t\t\t\t\t\t\tsocket.once('connect', timeConnect());\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tif (delays.secureConnect !== undefined && options.protocol === 'https:') {\n\t\trequest.once('socket', socket => {\n\t\t\t/* istanbul ignore next: hard to test */\n\t\t\tif (socket.connecting) {\n\t\t\t\tsocket.once('connect', () => {\n\t\t\t\t\tconst cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n\t\t\t\t\tsocket.once('secureConnect', cancelTimeout);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tif (delays.send !== undefined) {\n\t\trequest.once('socket', socket => {\n\t\t\tconst timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n\t\t\t/* istanbul ignore next: hard to test */\n\t\t\tif (socket.connecting) {\n\t\t\t\tsocket.once('connect', () => {\n\t\t\t\t\trequest.once('upload-complete', timeRequest());\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\trequest.once('upload-complete', timeRequest());\n\t\t\t}\n\t\t});\n\t}\n\n\tif (delays.response !== undefined) {\n\t\trequest.once('upload-complete', () => {\n\t\t\tconst cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n\t\t\trequest.once('response', cancelTimeout);\n\t\t});\n\t}\n};\n\nmodule.exports.TimeoutError = TimeoutError;\n"]},"metadata":{},"sourceType":"script"}