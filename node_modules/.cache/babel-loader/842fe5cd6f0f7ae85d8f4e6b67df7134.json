{"ast":null,"code":"'use strict';\n\nconst {\n  URL,\n  URLSearchParams\n} = require('url'); // TODO: Use the `URL` global when targeting Node.js 10\n\n\nconst urlLib = require('url');\n\nconst is = require('@sindresorhus/is');\n\nconst urlParseLax = require('url-parse-lax');\n\nconst lowercaseKeys = require('lowercase-keys');\n\nconst urlToOptions = require('./utils/url-to-options');\n\nconst isFormData = require('./utils/is-form-data');\n\nconst merge = require('./merge');\n\nconst knownHookEvents = require('./known-hook-events');\n\nconst retryAfterStatusCodes = new Set([413, 429, 503]); // `preNormalize` handles static options (e.g. headers).\n// For example, when you create a custom instance and make a request\n// with no static changes, they won't be normalized again.\n//\n// `normalize` operates on dynamic options - they cannot be saved.\n// For example, `body` is everytime different per request.\n// When it's done normalizing the new options, it performs merge()\n// on the prenormalized options and the normalized ones.\n\nconst preNormalize = (options, defaults) => {\n  if (is.nullOrUndefined(options.headers)) {\n    options.headers = {};\n  } else {\n    options.headers = lowercaseKeys(options.headers);\n  }\n\n  if (options.baseUrl && !options.baseUrl.toString().endsWith('/')) {\n    options.baseUrl += '/';\n  }\n\n  if (options.stream) {\n    options.json = false;\n  }\n\n  if (is.nullOrUndefined(options.hooks)) {\n    options.hooks = {};\n  } else if (!is.object(options.hooks)) {\n    throw new TypeError(`Parameter \\`hooks\\` must be an object, not ${is(options.hooks)}`);\n  }\n\n  for (const event of knownHookEvents) {\n    if (is.nullOrUndefined(options.hooks[event])) {\n      if (defaults) {\n        options.hooks[event] = [...defaults.hooks[event]];\n      } else {\n        options.hooks[event] = [];\n      }\n    }\n  }\n\n  if (is.number(options.timeout)) {\n    options.gotTimeout = {\n      request: options.timeout\n    };\n  } else if (is.object(options.timeout)) {\n    options.gotTimeout = options.timeout;\n  }\n\n  delete options.timeout;\n  const {\n    retry\n  } = options;\n  options.retry = {\n    retries: 0,\n    methods: [],\n    statusCodes: [],\n    errorCodes: []\n  };\n\n  if (is.nonEmptyObject(defaults) && retry !== false) {\n    options.retry = { ...defaults.retry\n    };\n  }\n\n  if (retry !== false) {\n    if (is.number(retry)) {\n      options.retry.retries = retry;\n    } else {\n      options.retry = { ...options.retry,\n        ...retry\n      };\n    }\n  }\n\n  if (options.gotTimeout) {\n    options.retry.maxRetryAfter = Math.min(...[options.gotTimeout.request, options.gotTimeout.connection].filter(n => !is.nullOrUndefined(n)));\n  }\n\n  if (is.array(options.retry.methods)) {\n    options.retry.methods = new Set(options.retry.methods.map(method => method.toUpperCase()));\n  }\n\n  if (is.array(options.retry.statusCodes)) {\n    options.retry.statusCodes = new Set(options.retry.statusCodes);\n  }\n\n  if (is.array(options.retry.errorCodes)) {\n    options.retry.errorCodes = new Set(options.retry.errorCodes);\n  }\n\n  return options;\n};\n\nconst normalize = (url, options, defaults) => {\n  if (is.plainObject(url)) {\n    options = { ...url,\n      ...options\n    };\n    url = options.url || {};\n    delete options.url;\n  }\n\n  if (defaults) {\n    options = merge({}, defaults.options, options ? preNormalize(options, defaults.options) : {});\n  } else {\n    options = merge({}, preNormalize(options));\n  }\n\n  if (!is.string(url) && !is.object(url)) {\n    throw new TypeError(`Parameter \\`url\\` must be a string or object, not ${is(url)}`);\n  }\n\n  if (is.string(url)) {\n    if (options.baseUrl) {\n      if (url.toString().startsWith('/')) {\n        url = url.toString().slice(1);\n      }\n\n      url = urlToOptions(new URL(url, options.baseUrl));\n    } else {\n      url = url.replace(/^unix:/, 'http://$&');\n      url = urlParseLax(url);\n    }\n  } else if (is(url) === 'URL') {\n    url = urlToOptions(url);\n  } // Override both null/undefined with default protocol\n\n\n  options = merge({\n    path: ''\n  }, url, {\n    protocol: url.protocol || 'https:'\n  }, options);\n\n  for (const hook of options.hooks.init) {\n    const called = hook(options);\n\n    if (is.promise(called)) {\n      throw new TypeError('The `init` hook must be a synchronous function');\n    }\n  }\n\n  const {\n    baseUrl\n  } = options;\n  Object.defineProperty(options, 'baseUrl', {\n    set: () => {\n      throw new Error('Failed to set baseUrl. Options are normalized already.');\n    },\n    get: () => baseUrl\n  });\n  const {\n    query\n  } = options;\n\n  if (is.nonEmptyString(query) || is.nonEmptyObject(query) || query instanceof URLSearchParams) {\n    if (!is.string(query)) {\n      options.query = new URLSearchParams(query).toString();\n    }\n\n    options.path = `${options.path.split('?')[0]}?${options.query}`;\n    delete options.query;\n  }\n\n  if (options.hostname === 'unix') {\n    const matches = /(.+?):(.+)/.exec(options.path);\n\n    if (matches) {\n      const [, socketPath, path] = matches;\n      options = { ...options,\n        socketPath,\n        path,\n        host: null\n      };\n    }\n  }\n\n  const {\n    headers\n  } = options;\n\n  for (const [key, value] of Object.entries(headers)) {\n    if (is.nullOrUndefined(value)) {\n      delete headers[key];\n    }\n  }\n\n  if (options.json && is.undefined(headers.accept)) {\n    headers.accept = 'application/json';\n  }\n\n  if (options.decompress && is.undefined(headers['accept-encoding'])) {\n    headers['accept-encoding'] = 'gzip, deflate';\n  }\n\n  const {\n    body\n  } = options;\n\n  if (is.nullOrUndefined(body)) {\n    options.method = options.method ? options.method.toUpperCase() : 'GET';\n  } else {\n    const isObject = is.object(body) && !is.buffer(body) && !is.nodeStream(body);\n\n    if (!is.nodeStream(body) && !is.string(body) && !is.buffer(body) && !(options.form || options.json)) {\n      throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');\n    }\n\n    if (options.json && !(isObject || is.array(body))) {\n      throw new TypeError('The `body` option must be an Object or Array when the `json` option is used');\n    }\n\n    if (options.form && !isObject) {\n      throw new TypeError('The `body` option must be an Object when the `form` option is used');\n    }\n\n    if (isFormData(body)) {\n      // Special case for https://github.com/form-data/form-data\n      headers['content-type'] = headers['content-type'] || `multipart/form-data; boundary=${body.getBoundary()}`;\n    } else if (options.form) {\n      headers['content-type'] = headers['content-type'] || 'application/x-www-form-urlencoded';\n      options.body = new URLSearchParams(body).toString();\n    } else if (options.json) {\n      headers['content-type'] = headers['content-type'] || 'application/json';\n      options.body = JSON.stringify(body);\n    }\n\n    options.method = options.method ? options.method.toUpperCase() : 'POST';\n  }\n\n  if (!is.function(options.retry.retries)) {\n    const {\n      retries\n    } = options.retry;\n\n    options.retry.retries = (iteration, error) => {\n      if (iteration > retries) {\n        return 0;\n      }\n\n      if ((!error || !options.retry.errorCodes.has(error.code)) && (!options.retry.methods.has(error.method) || !options.retry.statusCodes.has(error.statusCode))) {\n        return 0;\n      }\n\n      if (Reflect.has(error, 'headers') && Reflect.has(error.headers, 'retry-after') && retryAfterStatusCodes.has(error.statusCode)) {\n        let after = Number(error.headers['retry-after']);\n\n        if (is.nan(after)) {\n          after = Date.parse(error.headers['retry-after']) - Date.now();\n        } else {\n          after *= 1000;\n        }\n\n        if (after > options.retry.maxRetryAfter) {\n          return 0;\n        }\n\n        return after;\n      }\n\n      if (error.statusCode === 413) {\n        return 0;\n      }\n\n      const noise = Math.random() * 100;\n      return 2 ** (iteration - 1) * 1000 + noise;\n    };\n  }\n\n  return options;\n};\n\nconst reNormalize = options => normalize(urlLib.format(options), options);\n\nmodule.exports = normalize;\nmodule.exports.preNormalize = preNormalize;\nmodule.exports.reNormalize = reNormalize;","map":{"version":3,"sources":["/Users/kanavmittal/Downloads/Anonymous-Doubt-Session-Application-Ashank-App/node_modules/got/source/normalize-arguments.js"],"names":["URL","URLSearchParams","require","urlLib","is","urlParseLax","lowercaseKeys","urlToOptions","isFormData","merge","knownHookEvents","retryAfterStatusCodes","Set","preNormalize","options","defaults","nullOrUndefined","headers","baseUrl","toString","endsWith","stream","json","hooks","object","TypeError","event","number","timeout","gotTimeout","request","retry","retries","methods","statusCodes","errorCodes","nonEmptyObject","maxRetryAfter","Math","min","connection","filter","n","array","map","method","toUpperCase","normalize","url","plainObject","string","startsWith","slice","replace","path","protocol","hook","init","called","promise","Object","defineProperty","set","Error","get","query","nonEmptyString","split","hostname","matches","exec","socketPath","host","key","value","entries","undefined","accept","decompress","body","isObject","buffer","nodeStream","form","getBoundary","JSON","stringify","function","iteration","error","has","code","statusCode","Reflect","after","Number","nan","Date","parse","now","noise","random","reNormalize","format","module","exports"],"mappings":"AAAA;;AACA,MAAM;AAACA,EAAAA,GAAD;AAAMC,EAAAA;AAAN,IAAyBC,OAAO,CAAC,KAAD,CAAtC,C,CAA+C;;;AAC/C,MAAMC,MAAM,GAAGD,OAAO,CAAC,KAAD,CAAtB;;AACA,MAAME,EAAE,GAAGF,OAAO,CAAC,kBAAD,CAAlB;;AACA,MAAMG,WAAW,GAAGH,OAAO,CAAC,eAAD,CAA3B;;AACA,MAAMI,aAAa,GAAGJ,OAAO,CAAC,gBAAD,CAA7B;;AACA,MAAMK,YAAY,GAAGL,OAAO,CAAC,wBAAD,CAA5B;;AACA,MAAMM,UAAU,GAAGN,OAAO,CAAC,sBAAD,CAA1B;;AACA,MAAMO,KAAK,GAAGP,OAAO,CAAC,SAAD,CAArB;;AACA,MAAMQ,eAAe,GAAGR,OAAO,CAAC,qBAAD,CAA/B;;AAEA,MAAMS,qBAAqB,GAAG,IAAIC,GAAJ,CAAQ,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAR,CAA9B,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,YAAY,GAAG,CAACC,OAAD,EAAUC,QAAV,KAAuB;AAC3C,MAAIX,EAAE,CAACY,eAAH,CAAmBF,OAAO,CAACG,OAA3B,CAAJ,EAAyC;AACxCH,IAAAA,OAAO,CAACG,OAAR,GAAkB,EAAlB;AACA,GAFD,MAEO;AACNH,IAAAA,OAAO,CAACG,OAAR,GAAkBX,aAAa,CAACQ,OAAO,CAACG,OAAT,CAA/B;AACA;;AAED,MAAIH,OAAO,CAACI,OAAR,IAAmB,CAACJ,OAAO,CAACI,OAAR,CAAgBC,QAAhB,GAA2BC,QAA3B,CAAoC,GAApC,CAAxB,EAAkE;AACjEN,IAAAA,OAAO,CAACI,OAAR,IAAmB,GAAnB;AACA;;AAED,MAAIJ,OAAO,CAACO,MAAZ,EAAoB;AACnBP,IAAAA,OAAO,CAACQ,IAAR,GAAe,KAAf;AACA;;AAED,MAAIlB,EAAE,CAACY,eAAH,CAAmBF,OAAO,CAACS,KAA3B,CAAJ,EAAuC;AACtCT,IAAAA,OAAO,CAACS,KAAR,GAAgB,EAAhB;AACA,GAFD,MAEO,IAAI,CAACnB,EAAE,CAACoB,MAAH,CAAUV,OAAO,CAACS,KAAlB,CAAL,EAA+B;AACrC,UAAM,IAAIE,SAAJ,CAAe,8CAA6CrB,EAAE,CAACU,OAAO,CAACS,KAAT,CAAgB,EAA9E,CAAN;AACA;;AAED,OAAK,MAAMG,KAAX,IAAoBhB,eAApB,EAAqC;AACpC,QAAIN,EAAE,CAACY,eAAH,CAAmBF,OAAO,CAACS,KAAR,CAAcG,KAAd,CAAnB,CAAJ,EAA8C;AAC7C,UAAIX,QAAJ,EAAc;AACbD,QAAAA,OAAO,CAACS,KAAR,CAAcG,KAAd,IAAuB,CAAC,GAAGX,QAAQ,CAACQ,KAAT,CAAeG,KAAf,CAAJ,CAAvB;AACA,OAFD,MAEO;AACNZ,QAAAA,OAAO,CAACS,KAAR,CAAcG,KAAd,IAAuB,EAAvB;AACA;AACD;AACD;;AAED,MAAItB,EAAE,CAACuB,MAAH,CAAUb,OAAO,CAACc,OAAlB,CAAJ,EAAgC;AAC/Bd,IAAAA,OAAO,CAACe,UAAR,GAAqB;AAACC,MAAAA,OAAO,EAAEhB,OAAO,CAACc;AAAlB,KAArB;AACA,GAFD,MAEO,IAAIxB,EAAE,CAACoB,MAAH,CAAUV,OAAO,CAACc,OAAlB,CAAJ,EAAgC;AACtCd,IAAAA,OAAO,CAACe,UAAR,GAAqBf,OAAO,CAACc,OAA7B;AACA;;AAED,SAAOd,OAAO,CAACc,OAAf;AAEA,QAAM;AAACG,IAAAA;AAAD,MAAUjB,OAAhB;AACAA,EAAAA,OAAO,CAACiB,KAAR,GAAgB;AACfC,IAAAA,OAAO,EAAE,CADM;AAEfC,IAAAA,OAAO,EAAE,EAFM;AAGfC,IAAAA,WAAW,EAAE,EAHE;AAIfC,IAAAA,UAAU,EAAE;AAJG,GAAhB;;AAOA,MAAI/B,EAAE,CAACgC,cAAH,CAAkBrB,QAAlB,KAA+BgB,KAAK,KAAK,KAA7C,EAAoD;AACnDjB,IAAAA,OAAO,CAACiB,KAAR,GAAgB,EAAC,GAAGhB,QAAQ,CAACgB;AAAb,KAAhB;AACA;;AAED,MAAIA,KAAK,KAAK,KAAd,EAAqB;AACpB,QAAI3B,EAAE,CAACuB,MAAH,CAAUI,KAAV,CAAJ,EAAsB;AACrBjB,MAAAA,OAAO,CAACiB,KAAR,CAAcC,OAAd,GAAwBD,KAAxB;AACA,KAFD,MAEO;AACNjB,MAAAA,OAAO,CAACiB,KAAR,GAAgB,EAAC,GAAGjB,OAAO,CAACiB,KAAZ;AAAmB,WAAGA;AAAtB,OAAhB;AACA;AACD;;AAED,MAAIjB,OAAO,CAACe,UAAZ,EAAwB;AACvBf,IAAAA,OAAO,CAACiB,KAAR,CAAcM,aAAd,GAA8BC,IAAI,CAACC,GAAL,CAAS,GAAG,CAACzB,OAAO,CAACe,UAAR,CAAmBC,OAApB,EAA6BhB,OAAO,CAACe,UAAR,CAAmBW,UAAhD,EAA4DC,MAA5D,CAAmEC,CAAC,IAAI,CAACtC,EAAE,CAACY,eAAH,CAAmB0B,CAAnB,CAAzE,CAAZ,CAA9B;AACA;;AAED,MAAItC,EAAE,CAACuC,KAAH,CAAS7B,OAAO,CAACiB,KAAR,CAAcE,OAAvB,CAAJ,EAAqC;AACpCnB,IAAAA,OAAO,CAACiB,KAAR,CAAcE,OAAd,GAAwB,IAAIrB,GAAJ,CAAQE,OAAO,CAACiB,KAAR,CAAcE,OAAd,CAAsBW,GAAtB,CAA0BC,MAAM,IAAIA,MAAM,CAACC,WAAP,EAApC,CAAR,CAAxB;AACA;;AAED,MAAI1C,EAAE,CAACuC,KAAH,CAAS7B,OAAO,CAACiB,KAAR,CAAcG,WAAvB,CAAJ,EAAyC;AACxCpB,IAAAA,OAAO,CAACiB,KAAR,CAAcG,WAAd,GAA4B,IAAItB,GAAJ,CAAQE,OAAO,CAACiB,KAAR,CAAcG,WAAtB,CAA5B;AACA;;AAED,MAAI9B,EAAE,CAACuC,KAAH,CAAS7B,OAAO,CAACiB,KAAR,CAAcI,UAAvB,CAAJ,EAAwC;AACvCrB,IAAAA,OAAO,CAACiB,KAAR,CAAcI,UAAd,GAA2B,IAAIvB,GAAJ,CAAQE,OAAO,CAACiB,KAAR,CAAcI,UAAtB,CAA3B;AACA;;AAED,SAAOrB,OAAP;AACA,CA5ED;;AA8EA,MAAMiC,SAAS,GAAG,CAACC,GAAD,EAAMlC,OAAN,EAAeC,QAAf,KAA4B;AAC7C,MAAIX,EAAE,CAAC6C,WAAH,CAAeD,GAAf,CAAJ,EAAyB;AACxBlC,IAAAA,OAAO,GAAG,EAAC,GAAGkC,GAAJ;AAAS,SAAGlC;AAAZ,KAAV;AACAkC,IAAAA,GAAG,GAAGlC,OAAO,CAACkC,GAAR,IAAe,EAArB;AACA,WAAOlC,OAAO,CAACkC,GAAf;AACA;;AAED,MAAIjC,QAAJ,EAAc;AACbD,IAAAA,OAAO,GAAGL,KAAK,CAAC,EAAD,EAAKM,QAAQ,CAACD,OAAd,EAAuBA,OAAO,GAAGD,YAAY,CAACC,OAAD,EAAUC,QAAQ,CAACD,OAAnB,CAAf,GAA6C,EAA3E,CAAf;AACA,GAFD,MAEO;AACNA,IAAAA,OAAO,GAAGL,KAAK,CAAC,EAAD,EAAKI,YAAY,CAACC,OAAD,CAAjB,CAAf;AACA;;AAED,MAAI,CAACV,EAAE,CAAC8C,MAAH,CAAUF,GAAV,CAAD,IAAmB,CAAC5C,EAAE,CAACoB,MAAH,CAAUwB,GAAV,CAAxB,EAAwC;AACvC,UAAM,IAAIvB,SAAJ,CAAe,qDAAoDrB,EAAE,CAAC4C,GAAD,CAAM,EAA3E,CAAN;AACA;;AAED,MAAI5C,EAAE,CAAC8C,MAAH,CAAUF,GAAV,CAAJ,EAAoB;AACnB,QAAIlC,OAAO,CAACI,OAAZ,EAAqB;AACpB,UAAI8B,GAAG,CAAC7B,QAAJ,GAAegC,UAAf,CAA0B,GAA1B,CAAJ,EAAoC;AACnCH,QAAAA,GAAG,GAAGA,GAAG,CAAC7B,QAAJ,GAAeiC,KAAf,CAAqB,CAArB,CAAN;AACA;;AAEDJ,MAAAA,GAAG,GAAGzC,YAAY,CAAC,IAAIP,GAAJ,CAAQgD,GAAR,EAAalC,OAAO,CAACI,OAArB,CAAD,CAAlB;AACA,KAND,MAMO;AACN8B,MAAAA,GAAG,GAAGA,GAAG,CAACK,OAAJ,CAAY,QAAZ,EAAsB,WAAtB,CAAN;AACAL,MAAAA,GAAG,GAAG3C,WAAW,CAAC2C,GAAD,CAAjB;AACA;AACD,GAXD,MAWO,IAAI5C,EAAE,CAAC4C,GAAD,CAAF,KAAY,KAAhB,EAAuB;AAC7BA,IAAAA,GAAG,GAAGzC,YAAY,CAACyC,GAAD,CAAlB;AACA,GA9B4C,CAgC7C;;;AACAlC,EAAAA,OAAO,GAAGL,KAAK,CAAC;AAAC6C,IAAAA,IAAI,EAAE;AAAP,GAAD,EAAaN,GAAb,EAAkB;AAACO,IAAAA,QAAQ,EAAEP,GAAG,CAACO,QAAJ,IAAgB;AAA3B,GAAlB,EAAwDzC,OAAxD,CAAf;;AAEA,OAAK,MAAM0C,IAAX,IAAmB1C,OAAO,CAACS,KAAR,CAAckC,IAAjC,EAAuC;AACtC,UAAMC,MAAM,GAAGF,IAAI,CAAC1C,OAAD,CAAnB;;AAEA,QAAIV,EAAE,CAACuD,OAAH,CAAWD,MAAX,CAAJ,EAAwB;AACvB,YAAM,IAAIjC,SAAJ,CAAc,gDAAd,CAAN;AACA;AACD;;AAED,QAAM;AAACP,IAAAA;AAAD,MAAYJ,OAAlB;AACA8C,EAAAA,MAAM,CAACC,cAAP,CAAsB/C,OAAtB,EAA+B,SAA/B,EAA0C;AACzCgD,IAAAA,GAAG,EAAE,MAAM;AACV,YAAM,IAAIC,KAAJ,CAAU,wDAAV,CAAN;AACA,KAHwC;AAIzCC,IAAAA,GAAG,EAAE,MAAM9C;AAJ8B,GAA1C;AAOA,QAAM;AAAC+C,IAAAA;AAAD,MAAUnD,OAAhB;;AACA,MAAIV,EAAE,CAAC8D,cAAH,CAAkBD,KAAlB,KAA4B7D,EAAE,CAACgC,cAAH,CAAkB6B,KAAlB,CAA5B,IAAwDA,KAAK,YAAYhE,eAA7E,EAA8F;AAC7F,QAAI,CAACG,EAAE,CAAC8C,MAAH,CAAUe,KAAV,CAAL,EAAuB;AACtBnD,MAAAA,OAAO,CAACmD,KAAR,GAAiB,IAAIhE,eAAJ,CAAoBgE,KAApB,CAAD,CAA6B9C,QAA7B,EAAhB;AACA;;AAEDL,IAAAA,OAAO,CAACwC,IAAR,GAAgB,GAAExC,OAAO,CAACwC,IAAR,CAAaa,KAAb,CAAmB,GAAnB,EAAwB,CAAxB,CAA2B,IAAGrD,OAAO,CAACmD,KAAM,EAA9D;AACA,WAAOnD,OAAO,CAACmD,KAAf;AACA;;AAED,MAAInD,OAAO,CAACsD,QAAR,KAAqB,MAAzB,EAAiC;AAChC,UAAMC,OAAO,GAAG,aAAaC,IAAb,CAAkBxD,OAAO,CAACwC,IAA1B,CAAhB;;AAEA,QAAIe,OAAJ,EAAa;AACZ,YAAM,GAAGE,UAAH,EAAejB,IAAf,IAAuBe,OAA7B;AACAvD,MAAAA,OAAO,GAAG,EACT,GAAGA,OADM;AAETyD,QAAAA,UAFS;AAGTjB,QAAAA,IAHS;AAITkB,QAAAA,IAAI,EAAE;AAJG,OAAV;AAMA;AACD;;AAED,QAAM;AAACvD,IAAAA;AAAD,MAAYH,OAAlB;;AACA,OAAK,MAAM,CAAC2D,GAAD,EAAMC,KAAN,CAAX,IAA2Bd,MAAM,CAACe,OAAP,CAAe1D,OAAf,CAA3B,EAAoD;AACnD,QAAIb,EAAE,CAACY,eAAH,CAAmB0D,KAAnB,CAAJ,EAA+B;AAC9B,aAAOzD,OAAO,CAACwD,GAAD,CAAd;AACA;AACD;;AAED,MAAI3D,OAAO,CAACQ,IAAR,IAAgBlB,EAAE,CAACwE,SAAH,CAAa3D,OAAO,CAAC4D,MAArB,CAApB,EAAkD;AACjD5D,IAAAA,OAAO,CAAC4D,MAAR,GAAiB,kBAAjB;AACA;;AAED,MAAI/D,OAAO,CAACgE,UAAR,IAAsB1E,EAAE,CAACwE,SAAH,CAAa3D,OAAO,CAAC,iBAAD,CAApB,CAA1B,EAAoE;AACnEA,IAAAA,OAAO,CAAC,iBAAD,CAAP,GAA6B,eAA7B;AACA;;AAED,QAAM;AAAC8D,IAAAA;AAAD,MAASjE,OAAf;;AACA,MAAIV,EAAE,CAACY,eAAH,CAAmB+D,IAAnB,CAAJ,EAA8B;AAC7BjE,IAAAA,OAAO,CAAC+B,MAAR,GAAiB/B,OAAO,CAAC+B,MAAR,GAAiB/B,OAAO,CAAC+B,MAAR,CAAeC,WAAf,EAAjB,GAAgD,KAAjE;AACA,GAFD,MAEO;AACN,UAAMkC,QAAQ,GAAG5E,EAAE,CAACoB,MAAH,CAAUuD,IAAV,KAAmB,CAAC3E,EAAE,CAAC6E,MAAH,CAAUF,IAAV,CAApB,IAAuC,CAAC3E,EAAE,CAAC8E,UAAH,CAAcH,IAAd,CAAzD;;AACA,QAAI,CAAC3E,EAAE,CAAC8E,UAAH,CAAcH,IAAd,CAAD,IAAwB,CAAC3E,EAAE,CAAC8C,MAAH,CAAU6B,IAAV,CAAzB,IAA4C,CAAC3E,EAAE,CAAC6E,MAAH,CAAUF,IAAV,CAA7C,IAAgE,EAAEjE,OAAO,CAACqE,IAAR,IAAgBrE,OAAO,CAACQ,IAA1B,CAApE,EAAqG;AACpG,YAAM,IAAIG,SAAJ,CAAc,+DAAd,CAAN;AACA;;AAED,QAAIX,OAAO,CAACQ,IAAR,IAAgB,EAAE0D,QAAQ,IAAI5E,EAAE,CAACuC,KAAH,CAASoC,IAAT,CAAd,CAApB,EAAmD;AAClD,YAAM,IAAItD,SAAJ,CAAc,6EAAd,CAAN;AACA;;AAED,QAAIX,OAAO,CAACqE,IAAR,IAAgB,CAACH,QAArB,EAA+B;AAC9B,YAAM,IAAIvD,SAAJ,CAAc,oEAAd,CAAN;AACA;;AAED,QAAIjB,UAAU,CAACuE,IAAD,CAAd,EAAsB;AACrB;AACA9D,MAAAA,OAAO,CAAC,cAAD,CAAP,GAA0BA,OAAO,CAAC,cAAD,CAAP,IAA4B,iCAAgC8D,IAAI,CAACK,WAAL,EAAmB,EAAzG;AACA,KAHD,MAGO,IAAItE,OAAO,CAACqE,IAAZ,EAAkB;AACxBlE,MAAAA,OAAO,CAAC,cAAD,CAAP,GAA0BA,OAAO,CAAC,cAAD,CAAP,IAA2B,mCAArD;AACAH,MAAAA,OAAO,CAACiE,IAAR,GAAgB,IAAI9E,eAAJ,CAAoB8E,IAApB,CAAD,CAA4B5D,QAA5B,EAAf;AACA,KAHM,MAGA,IAAIL,OAAO,CAACQ,IAAZ,EAAkB;AACxBL,MAAAA,OAAO,CAAC,cAAD,CAAP,GAA0BA,OAAO,CAAC,cAAD,CAAP,IAA2B,kBAArD;AACAH,MAAAA,OAAO,CAACiE,IAAR,GAAeM,IAAI,CAACC,SAAL,CAAeP,IAAf,CAAf;AACA;;AAEDjE,IAAAA,OAAO,CAAC+B,MAAR,GAAiB/B,OAAO,CAAC+B,MAAR,GAAiB/B,OAAO,CAAC+B,MAAR,CAAeC,WAAf,EAAjB,GAAgD,MAAjE;AACA;;AAED,MAAI,CAAC1C,EAAE,CAACmF,QAAH,CAAYzE,OAAO,CAACiB,KAAR,CAAcC,OAA1B,CAAL,EAAyC;AACxC,UAAM;AAACA,MAAAA;AAAD,QAAYlB,OAAO,CAACiB,KAA1B;;AAEAjB,IAAAA,OAAO,CAACiB,KAAR,CAAcC,OAAd,GAAwB,CAACwD,SAAD,EAAYC,KAAZ,KAAsB;AAC7C,UAAID,SAAS,GAAGxD,OAAhB,EAAyB;AACxB,eAAO,CAAP;AACA;;AAED,UAAI,CAAC,CAACyD,KAAD,IAAU,CAAC3E,OAAO,CAACiB,KAAR,CAAcI,UAAd,CAAyBuD,GAAzB,CAA6BD,KAAK,CAACE,IAAnC,CAAZ,MAA0D,CAAC7E,OAAO,CAACiB,KAAR,CAAcE,OAAd,CAAsByD,GAAtB,CAA0BD,KAAK,CAAC5C,MAAhC,CAAD,IAA4C,CAAC/B,OAAO,CAACiB,KAAR,CAAcG,WAAd,CAA0BwD,GAA1B,CAA8BD,KAAK,CAACG,UAApC,CAAvG,CAAJ,EAA6J;AAC5J,eAAO,CAAP;AACA;;AAED,UAAIC,OAAO,CAACH,GAAR,CAAYD,KAAZ,EAAmB,SAAnB,KAAiCI,OAAO,CAACH,GAAR,CAAYD,KAAK,CAACxE,OAAlB,EAA2B,aAA3B,CAAjC,IAA8EN,qBAAqB,CAAC+E,GAAtB,CAA0BD,KAAK,CAACG,UAAhC,CAAlF,EAA+H;AAC9H,YAAIE,KAAK,GAAGC,MAAM,CAACN,KAAK,CAACxE,OAAN,CAAc,aAAd,CAAD,CAAlB;;AACA,YAAIb,EAAE,CAAC4F,GAAH,CAAOF,KAAP,CAAJ,EAAmB;AAClBA,UAAAA,KAAK,GAAGG,IAAI,CAACC,KAAL,CAAWT,KAAK,CAACxE,OAAN,CAAc,aAAd,CAAX,IAA2CgF,IAAI,CAACE,GAAL,EAAnD;AACA,SAFD,MAEO;AACNL,UAAAA,KAAK,IAAI,IAAT;AACA;;AAED,YAAIA,KAAK,GAAGhF,OAAO,CAACiB,KAAR,CAAcM,aAA1B,EAAyC;AACxC,iBAAO,CAAP;AACA;;AAED,eAAOyD,KAAP;AACA;;AAED,UAAIL,KAAK,CAACG,UAAN,KAAqB,GAAzB,EAA8B;AAC7B,eAAO,CAAP;AACA;;AAED,YAAMQ,KAAK,GAAG9D,IAAI,CAAC+D,MAAL,KAAgB,GAA9B;AACA,aAAS,MAAMb,SAAS,GAAG,CAAlB,CAAD,GAAyB,IAA1B,GAAkCY,KAAzC;AACA,KA9BD;AA+BA;;AAED,SAAOtF,OAAP;AACA,CA9JD;;AAgKA,MAAMwF,WAAW,GAAGxF,OAAO,IAAIiC,SAAS,CAAC5C,MAAM,CAACoG,MAAP,CAAczF,OAAd,CAAD,EAAyBA,OAAzB,CAAxC;;AAEA0F,MAAM,CAACC,OAAP,GAAiB1D,SAAjB;AACAyD,MAAM,CAACC,OAAP,CAAe5F,YAAf,GAA8BA,YAA9B;AACA2F,MAAM,CAACC,OAAP,CAAeH,WAAf,GAA6BA,WAA7B","sourcesContent":["'use strict';\nconst {URL, URLSearchParams} = require('url'); // TODO: Use the `URL` global when targeting Node.js 10\nconst urlLib = require('url');\nconst is = require('@sindresorhus/is');\nconst urlParseLax = require('url-parse-lax');\nconst lowercaseKeys = require('lowercase-keys');\nconst urlToOptions = require('./utils/url-to-options');\nconst isFormData = require('./utils/is-form-data');\nconst merge = require('./merge');\nconst knownHookEvents = require('./known-hook-events');\n\nconst retryAfterStatusCodes = new Set([413, 429, 503]);\n\n// `preNormalize` handles static options (e.g. headers).\n// For example, when you create a custom instance and make a request\n// with no static changes, they won't be normalized again.\n//\n// `normalize` operates on dynamic options - they cannot be saved.\n// For example, `body` is everytime different per request.\n// When it's done normalizing the new options, it performs merge()\n// on the prenormalized options and the normalized ones.\n\nconst preNormalize = (options, defaults) => {\n\tif (is.nullOrUndefined(options.headers)) {\n\t\toptions.headers = {};\n\t} else {\n\t\toptions.headers = lowercaseKeys(options.headers);\n\t}\n\n\tif (options.baseUrl && !options.baseUrl.toString().endsWith('/')) {\n\t\toptions.baseUrl += '/';\n\t}\n\n\tif (options.stream) {\n\t\toptions.json = false;\n\t}\n\n\tif (is.nullOrUndefined(options.hooks)) {\n\t\toptions.hooks = {};\n\t} else if (!is.object(options.hooks)) {\n\t\tthrow new TypeError(`Parameter \\`hooks\\` must be an object, not ${is(options.hooks)}`);\n\t}\n\n\tfor (const event of knownHookEvents) {\n\t\tif (is.nullOrUndefined(options.hooks[event])) {\n\t\t\tif (defaults) {\n\t\t\t\toptions.hooks[event] = [...defaults.hooks[event]];\n\t\t\t} else {\n\t\t\t\toptions.hooks[event] = [];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is.number(options.timeout)) {\n\t\toptions.gotTimeout = {request: options.timeout};\n\t} else if (is.object(options.timeout)) {\n\t\toptions.gotTimeout = options.timeout;\n\t}\n\n\tdelete options.timeout;\n\n\tconst {retry} = options;\n\toptions.retry = {\n\t\tretries: 0,\n\t\tmethods: [],\n\t\tstatusCodes: [],\n\t\terrorCodes: []\n\t};\n\n\tif (is.nonEmptyObject(defaults) && retry !== false) {\n\t\toptions.retry = {...defaults.retry};\n\t}\n\n\tif (retry !== false) {\n\t\tif (is.number(retry)) {\n\t\t\toptions.retry.retries = retry;\n\t\t} else {\n\t\t\toptions.retry = {...options.retry, ...retry};\n\t\t}\n\t}\n\n\tif (options.gotTimeout) {\n\t\toptions.retry.maxRetryAfter = Math.min(...[options.gotTimeout.request, options.gotTimeout.connection].filter(n => !is.nullOrUndefined(n)));\n\t}\n\n\tif (is.array(options.retry.methods)) {\n\t\toptions.retry.methods = new Set(options.retry.methods.map(method => method.toUpperCase()));\n\t}\n\n\tif (is.array(options.retry.statusCodes)) {\n\t\toptions.retry.statusCodes = new Set(options.retry.statusCodes);\n\t}\n\n\tif (is.array(options.retry.errorCodes)) {\n\t\toptions.retry.errorCodes = new Set(options.retry.errorCodes);\n\t}\n\n\treturn options;\n};\n\nconst normalize = (url, options, defaults) => {\n\tif (is.plainObject(url)) {\n\t\toptions = {...url, ...options};\n\t\turl = options.url || {};\n\t\tdelete options.url;\n\t}\n\n\tif (defaults) {\n\t\toptions = merge({}, defaults.options, options ? preNormalize(options, defaults.options) : {});\n\t} else {\n\t\toptions = merge({}, preNormalize(options));\n\t}\n\n\tif (!is.string(url) && !is.object(url)) {\n\t\tthrow new TypeError(`Parameter \\`url\\` must be a string or object, not ${is(url)}`);\n\t}\n\n\tif (is.string(url)) {\n\t\tif (options.baseUrl) {\n\t\t\tif (url.toString().startsWith('/')) {\n\t\t\t\turl = url.toString().slice(1);\n\t\t\t}\n\n\t\t\turl = urlToOptions(new URL(url, options.baseUrl));\n\t\t} else {\n\t\t\turl = url.replace(/^unix:/, 'http://$&');\n\t\t\turl = urlParseLax(url);\n\t\t}\n\t} else if (is(url) === 'URL') {\n\t\turl = urlToOptions(url);\n\t}\n\n\t// Override both null/undefined with default protocol\n\toptions = merge({path: ''}, url, {protocol: url.protocol || 'https:'}, options);\n\n\tfor (const hook of options.hooks.init) {\n\t\tconst called = hook(options);\n\n\t\tif (is.promise(called)) {\n\t\t\tthrow new TypeError('The `init` hook must be a synchronous function');\n\t\t}\n\t}\n\n\tconst {baseUrl} = options;\n\tObject.defineProperty(options, 'baseUrl', {\n\t\tset: () => {\n\t\t\tthrow new Error('Failed to set baseUrl. Options are normalized already.');\n\t\t},\n\t\tget: () => baseUrl\n\t});\n\n\tconst {query} = options;\n\tif (is.nonEmptyString(query) || is.nonEmptyObject(query) || query instanceof URLSearchParams) {\n\t\tif (!is.string(query)) {\n\t\t\toptions.query = (new URLSearchParams(query)).toString();\n\t\t}\n\n\t\toptions.path = `${options.path.split('?')[0]}?${options.query}`;\n\t\tdelete options.query;\n\t}\n\n\tif (options.hostname === 'unix') {\n\t\tconst matches = /(.+?):(.+)/.exec(options.path);\n\n\t\tif (matches) {\n\t\t\tconst [, socketPath, path] = matches;\n\t\t\toptions = {\n\t\t\t\t...options,\n\t\t\t\tsocketPath,\n\t\t\t\tpath,\n\t\t\t\thost: null\n\t\t\t};\n\t\t}\n\t}\n\n\tconst {headers} = options;\n\tfor (const [key, value] of Object.entries(headers)) {\n\t\tif (is.nullOrUndefined(value)) {\n\t\t\tdelete headers[key];\n\t\t}\n\t}\n\n\tif (options.json && is.undefined(headers.accept)) {\n\t\theaders.accept = 'application/json';\n\t}\n\n\tif (options.decompress && is.undefined(headers['accept-encoding'])) {\n\t\theaders['accept-encoding'] = 'gzip, deflate';\n\t}\n\n\tconst {body} = options;\n\tif (is.nullOrUndefined(body)) {\n\t\toptions.method = options.method ? options.method.toUpperCase() : 'GET';\n\t} else {\n\t\tconst isObject = is.object(body) && !is.buffer(body) && !is.nodeStream(body);\n\t\tif (!is.nodeStream(body) && !is.string(body) && !is.buffer(body) && !(options.form || options.json)) {\n\t\t\tthrow new TypeError('The `body` option must be a stream.Readable, string or Buffer');\n\t\t}\n\n\t\tif (options.json && !(isObject || is.array(body))) {\n\t\t\tthrow new TypeError('The `body` option must be an Object or Array when the `json` option is used');\n\t\t}\n\n\t\tif (options.form && !isObject) {\n\t\t\tthrow new TypeError('The `body` option must be an Object when the `form` option is used');\n\t\t}\n\n\t\tif (isFormData(body)) {\n\t\t\t// Special case for https://github.com/form-data/form-data\n\t\t\theaders['content-type'] = headers['content-type'] || `multipart/form-data; boundary=${body.getBoundary()}`;\n\t\t} else if (options.form) {\n\t\t\theaders['content-type'] = headers['content-type'] || 'application/x-www-form-urlencoded';\n\t\t\toptions.body = (new URLSearchParams(body)).toString();\n\t\t} else if (options.json) {\n\t\t\theaders['content-type'] = headers['content-type'] || 'application/json';\n\t\t\toptions.body = JSON.stringify(body);\n\t\t}\n\n\t\toptions.method = options.method ? options.method.toUpperCase() : 'POST';\n\t}\n\n\tif (!is.function(options.retry.retries)) {\n\t\tconst {retries} = options.retry;\n\n\t\toptions.retry.retries = (iteration, error) => {\n\t\t\tif (iteration > retries) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif ((!error || !options.retry.errorCodes.has(error.code)) && (!options.retry.methods.has(error.method) || !options.retry.statusCodes.has(error.statusCode))) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (Reflect.has(error, 'headers') && Reflect.has(error.headers, 'retry-after') && retryAfterStatusCodes.has(error.statusCode)) {\n\t\t\t\tlet after = Number(error.headers['retry-after']);\n\t\t\t\tif (is.nan(after)) {\n\t\t\t\t\tafter = Date.parse(error.headers['retry-after']) - Date.now();\n\t\t\t\t} else {\n\t\t\t\t\tafter *= 1000;\n\t\t\t\t}\n\n\t\t\t\tif (after > options.retry.maxRetryAfter) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn after;\n\t\t\t}\n\n\t\t\tif (error.statusCode === 413) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tconst noise = Math.random() * 100;\n\t\t\treturn ((2 ** (iteration - 1)) * 1000) + noise;\n\t\t};\n\t}\n\n\treturn options;\n};\n\nconst reNormalize = options => normalize(urlLib.format(options), options);\n\nmodule.exports = normalize;\nmodule.exports.preNormalize = preNormalize;\nmodule.exports.reNormalize = reNormalize;\n"]},"metadata":{},"sourceType":"script"}