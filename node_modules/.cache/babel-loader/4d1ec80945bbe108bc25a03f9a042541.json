{"ast":null,"code":"'use strict';\n\nconst {\n  URL\n} = require('url'); // TODO: Use the `URL` global when targeting Node.js 10\n\n\nconst util = require('util');\n\nconst EventEmitter = require('events');\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst urlLib = require('url');\n\nconst CacheableRequest = require('cacheable-request');\n\nconst toReadableStream = require('to-readable-stream');\n\nconst is = require('@sindresorhus/is');\n\nconst timer = require('@szmarczak/http-timer');\n\nconst timedOut = require('./utils/timed-out');\n\nconst getBodySize = require('./utils/get-body-size');\n\nconst getResponse = require('./get-response');\n\nconst progress = require('./progress');\n\nconst {\n  CacheError,\n  UnsupportedProtocolError,\n  MaxRedirectsError,\n  RequestError,\n  TimeoutError\n} = require('./errors');\n\nconst urlToOptions = require('./utils/url-to-options');\n\nconst getMethodRedirectCodes = new Set([300, 301, 302, 303, 304, 305, 307, 308]);\nconst allMethodRedirectCodes = new Set([300, 303, 307, 308]);\n\nmodule.exports = (options, input) => {\n  const emitter = new EventEmitter();\n  const redirects = [];\n  let currentRequest;\n  let requestUrl;\n  let redirectString;\n  let uploadBodySize;\n  let retryCount = 0;\n  let shouldAbort = false;\n  const setCookie = options.cookieJar ? util.promisify(options.cookieJar.setCookie.bind(options.cookieJar)) : null;\n  const getCookieString = options.cookieJar ? util.promisify(options.cookieJar.getCookieString.bind(options.cookieJar)) : null;\n  const agents = is.object(options.agent) ? options.agent : null;\n\n  const emitError = async error => {\n    try {\n      for (const hook of options.hooks.beforeError) {\n        // eslint-disable-next-line no-await-in-loop\n        error = await hook(error);\n      }\n\n      emitter.emit('error', error);\n    } catch (error2) {\n      emitter.emit('error', error2);\n    }\n  };\n\n  const get = async options => {\n    const currentUrl = redirectString || requestUrl;\n\n    if (options.protocol !== 'http:' && options.protocol !== 'https:') {\n      throw new UnsupportedProtocolError(options);\n    }\n\n    decodeURI(currentUrl);\n    let fn;\n\n    if (is.function(options.request)) {\n      fn = {\n        request: options.request\n      };\n    } else {\n      fn = options.protocol === 'https:' ? https : http;\n    }\n\n    if (agents) {\n      const protocolName = options.protocol === 'https:' ? 'https' : 'http';\n      options.agent = agents[protocolName] || options.agent;\n    }\n    /* istanbul ignore next: electron.net is broken */\n\n\n    if (options.useElectronNet && process.versions.electron) {\n      const r = {\n        x: require\n      }['yx'.slice(1)]; // Trick webpack\n\n      const electron = r('electron');\n      fn = electron.net || electron.remote.net;\n    }\n\n    if (options.cookieJar) {\n      const cookieString = await getCookieString(currentUrl, {});\n\n      if (is.nonEmptyString(cookieString)) {\n        options.headers.cookie = cookieString;\n      }\n    }\n\n    let timings;\n\n    const handleResponse = async response => {\n      try {\n        /* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */\n        if (options.useElectronNet) {\n          response = new Proxy(response, {\n            get: (target, name) => {\n              if (name === 'trailers' || name === 'rawTrailers') {\n                return [];\n              }\n\n              const value = target[name];\n              return is.function(value) ? value.bind(target) : value;\n            }\n          });\n        }\n\n        const {\n          statusCode\n        } = response;\n        response.url = currentUrl;\n        response.requestUrl = requestUrl;\n        response.retryCount = retryCount;\n        response.timings = timings;\n        response.redirectUrls = redirects;\n        response.request = {\n          gotOptions: options\n        };\n        const rawCookies = response.headers['set-cookie'];\n\n        if (options.cookieJar && rawCookies) {\n          await Promise.all(rawCookies.map(rawCookie => setCookie(rawCookie, response.url)));\n        }\n\n        if (options.followRedirect && 'location' in response.headers) {\n          if (allMethodRedirectCodes.has(statusCode) || getMethodRedirectCodes.has(statusCode) && (options.method === 'GET' || options.method === 'HEAD')) {\n            response.resume(); // We're being redirected, we don't care about the response.\n\n            if (statusCode === 303) {\n              // Server responded with \"see other\", indicating that the resource exists at another location,\n              // and the client should request it from that location via GET or HEAD.\n              options.method = 'GET';\n            }\n\n            if (redirects.length >= 10) {\n              throw new MaxRedirectsError(statusCode, redirects, options);\n            } // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604\n\n\n            const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n            const redirectURL = new URL(redirectBuffer, currentUrl);\n            redirectString = redirectURL.toString();\n            redirects.push(redirectString);\n            const redirectOptions = { ...options,\n              ...urlToOptions(redirectURL)\n            };\n\n            for (const hook of options.hooks.beforeRedirect) {\n              // eslint-disable-next-line no-await-in-loop\n              await hook(redirectOptions);\n            }\n\n            emitter.emit('redirect', response, redirectOptions);\n            await get(redirectOptions);\n            return;\n          }\n        }\n\n        getResponse(response, options, emitter);\n      } catch (error) {\n        emitError(error);\n      }\n    };\n\n    const handleRequest = request => {\n      if (shouldAbort) {\n        request.once('error', () => {});\n        request.abort();\n        return;\n      }\n\n      currentRequest = request;\n      request.once('error', error => {\n        if (request.aborted) {\n          return;\n        }\n\n        if (error instanceof timedOut.TimeoutError) {\n          error = new TimeoutError(error, options);\n        } else {\n          error = new RequestError(error, options);\n        }\n\n        if (emitter.retry(error) === false) {\n          emitError(error);\n        }\n      });\n      timings = timer(request);\n      progress.upload(request, emitter, uploadBodySize);\n\n      if (options.gotTimeout) {\n        timedOut(request, options.gotTimeout, options);\n      }\n\n      emitter.emit('request', request);\n\n      const uploadComplete = () => {\n        request.emit('upload-complete');\n      };\n\n      try {\n        if (is.nodeStream(options.body)) {\n          options.body.once('end', uploadComplete);\n          options.body.pipe(request);\n          options.body = undefined;\n        } else if (options.body) {\n          request.end(options.body, uploadComplete);\n        } else if (input && (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH')) {\n          input.once('end', uploadComplete);\n          input.pipe(request);\n        } else {\n          request.end(uploadComplete);\n        }\n      } catch (error) {\n        emitError(new RequestError(error, options));\n      }\n    };\n\n    if (options.cache) {\n      const cacheableRequest = new CacheableRequest(fn.request, options.cache);\n      const cacheRequest = cacheableRequest(options, handleResponse);\n      cacheRequest.once('error', error => {\n        if (error instanceof CacheableRequest.RequestError) {\n          emitError(new RequestError(error, options));\n        } else {\n          emitError(new CacheError(error, options));\n        }\n      });\n      cacheRequest.once('request', handleRequest);\n    } else {\n      // Catches errors thrown by calling fn.request(...)\n      try {\n        handleRequest(fn.request(options, handleResponse));\n      } catch (error) {\n        emitError(new RequestError(error, options));\n      }\n    }\n  };\n\n  emitter.retry = error => {\n    let backoff;\n\n    try {\n      backoff = options.retry.retries(++retryCount, error);\n    } catch (error2) {\n      emitError(error2);\n      return;\n    }\n\n    if (backoff) {\n      const retry = async options => {\n        try {\n          for (const hook of options.hooks.beforeRetry) {\n            // eslint-disable-next-line no-await-in-loop\n            await hook(options, error, retryCount);\n          }\n\n          await get(options);\n        } catch (error) {\n          emitError(error);\n        }\n      };\n\n      setTimeout(retry, backoff, { ...options,\n        forceRefresh: true\n      });\n      return true;\n    }\n\n    return false;\n  };\n\n  emitter.abort = () => {\n    if (currentRequest) {\n      currentRequest.once('error', () => {});\n      currentRequest.abort();\n    } else {\n      shouldAbort = true;\n    }\n  };\n\n  setImmediate(async () => {\n    try {\n      // Convert buffer to stream to receive upload progress events (#322)\n      const {\n        body\n      } = options;\n\n      if (is.buffer(body)) {\n        options.body = toReadableStream(body);\n        uploadBodySize = body.length;\n      } else {\n        uploadBodySize = await getBodySize(options);\n      }\n\n      if (is.undefined(options.headers['content-length']) && is.undefined(options.headers['transfer-encoding'])) {\n        if ((uploadBodySize > 0 || options.method === 'PUT') && !is.null(uploadBodySize)) {\n          options.headers['content-length'] = uploadBodySize;\n        }\n      }\n\n      for (const hook of options.hooks.beforeRequest) {\n        // eslint-disable-next-line no-await-in-loop\n        await hook(options);\n      }\n\n      requestUrl = options.href || new URL(options.path, urlLib.format(options)).toString();\n      await get(options);\n    } catch (error) {\n      emitError(error);\n    }\n  });\n  return emitter;\n};","map":{"version":3,"sources":["/Users/kanavmittal/Downloads/Anonymous-Doubt-Session-Application-Ashank-App/node_modules/got/source/request-as-event-emitter.js"],"names":["URL","require","util","EventEmitter","http","https","urlLib","CacheableRequest","toReadableStream","is","timer","timedOut","getBodySize","getResponse","progress","CacheError","UnsupportedProtocolError","MaxRedirectsError","RequestError","TimeoutError","urlToOptions","getMethodRedirectCodes","Set","allMethodRedirectCodes","module","exports","options","input","emitter","redirects","currentRequest","requestUrl","redirectString","uploadBodySize","retryCount","shouldAbort","setCookie","cookieJar","promisify","bind","getCookieString","agents","object","agent","emitError","error","hook","hooks","beforeError","emit","error2","get","currentUrl","protocol","decodeURI","fn","function","request","protocolName","useElectronNet","process","versions","electron","r","x","slice","net","remote","cookieString","nonEmptyString","headers","cookie","timings","handleResponse","response","Proxy","target","name","value","statusCode","url","redirectUrls","gotOptions","rawCookies","Promise","all","map","rawCookie","followRedirect","has","method","resume","length","redirectBuffer","Buffer","from","location","toString","redirectURL","push","redirectOptions","beforeRedirect","handleRequest","once","abort","aborted","retry","upload","gotTimeout","uploadComplete","nodeStream","body","pipe","undefined","end","cache","cacheableRequest","cacheRequest","backoff","retries","beforeRetry","setTimeout","forceRefresh","setImmediate","buffer","null","beforeRequest","href","path","format"],"mappings":"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","sourcesContent":["'use strict';\nconst {URL} = require('url'); // TODO: Use the `URL` global when targeting Node.js 10\nconst util = require('util');\nconst EventEmitter = require('events');\nconst http = require('http');\nconst https = require('https');\nconst urlLib = require('url');\nconst CacheableRequest = require('cacheable-request');\nconst toReadableStream = require('to-readable-stream');\nconst is = require('@sindresorhus/is');\nconst timer = require('@szmarczak/http-timer');\nconst timedOut = require('./utils/timed-out');\nconst getBodySize = require('./utils/get-body-size');\nconst getResponse = require('./get-response');\nconst progress = require('./progress');\nconst {CacheError, UnsupportedProtocolError, MaxRedirectsError, RequestError, TimeoutError} = require('./errors');\nconst urlToOptions = require('./utils/url-to-options');\n\nconst getMethodRedirectCodes = new Set([300, 301, 302, 303, 304, 305, 307, 308]);\nconst allMethodRedirectCodes = new Set([300, 303, 307, 308]);\n\nmodule.exports = (options, input) => {\n\tconst emitter = new EventEmitter();\n\tconst redirects = [];\n\tlet currentRequest;\n\tlet requestUrl;\n\tlet redirectString;\n\tlet uploadBodySize;\n\tlet retryCount = 0;\n\tlet shouldAbort = false;\n\n\tconst setCookie = options.cookieJar ? util.promisify(options.cookieJar.setCookie.bind(options.cookieJar)) : null;\n\tconst getCookieString = options.cookieJar ? util.promisify(options.cookieJar.getCookieString.bind(options.cookieJar)) : null;\n\tconst agents = is.object(options.agent) ? options.agent : null;\n\n\tconst emitError = async error => {\n\t\ttry {\n\t\t\tfor (const hook of options.hooks.beforeError) {\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\terror = await hook(error);\n\t\t\t}\n\n\t\t\temitter.emit('error', error);\n\t\t} catch (error2) {\n\t\t\temitter.emit('error', error2);\n\t\t}\n\t};\n\n\tconst get = async options => {\n\t\tconst currentUrl = redirectString || requestUrl;\n\n\t\tif (options.protocol !== 'http:' && options.protocol !== 'https:') {\n\t\t\tthrow new UnsupportedProtocolError(options);\n\t\t}\n\n\t\tdecodeURI(currentUrl);\n\n\t\tlet fn;\n\t\tif (is.function(options.request)) {\n\t\t\tfn = {request: options.request};\n\t\t} else {\n\t\t\tfn = options.protocol === 'https:' ? https : http;\n\t\t}\n\n\t\tif (agents) {\n\t\t\tconst protocolName = options.protocol === 'https:' ? 'https' : 'http';\n\t\t\toptions.agent = agents[protocolName] || options.agent;\n\t\t}\n\n\t\t/* istanbul ignore next: electron.net is broken */\n\t\tif (options.useElectronNet && process.versions.electron) {\n\t\t\tconst r = ({x: require})['yx'.slice(1)]; // Trick webpack\n\t\t\tconst electron = r('electron');\n\t\t\tfn = electron.net || electron.remote.net;\n\t\t}\n\n\t\tif (options.cookieJar) {\n\t\t\tconst cookieString = await getCookieString(currentUrl, {});\n\n\t\t\tif (is.nonEmptyString(cookieString)) {\n\t\t\t\toptions.headers.cookie = cookieString;\n\t\t\t}\n\t\t}\n\n\t\tlet timings;\n\t\tconst handleResponse = async response => {\n\t\t\ttry {\n\t\t\t\t/* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */\n\t\t\t\tif (options.useElectronNet) {\n\t\t\t\t\tresponse = new Proxy(response, {\n\t\t\t\t\t\tget: (target, name) => {\n\t\t\t\t\t\t\tif (name === 'trailers' || name === 'rawTrailers') {\n\t\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst value = target[name];\n\t\t\t\t\t\t\treturn is.function(value) ? value.bind(target) : value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst {statusCode} = response;\n\t\t\t\tresponse.url = currentUrl;\n\t\t\t\tresponse.requestUrl = requestUrl;\n\t\t\t\tresponse.retryCount = retryCount;\n\t\t\t\tresponse.timings = timings;\n\t\t\t\tresponse.redirectUrls = redirects;\n\t\t\t\tresponse.request = {\n\t\t\t\t\tgotOptions: options\n\t\t\t\t};\n\n\t\t\t\tconst rawCookies = response.headers['set-cookie'];\n\t\t\t\tif (options.cookieJar && rawCookies) {\n\t\t\t\t\tawait Promise.all(rawCookies.map(rawCookie => setCookie(rawCookie, response.url)));\n\t\t\t\t}\n\n\t\t\t\tif (options.followRedirect && 'location' in response.headers) {\n\t\t\t\t\tif (allMethodRedirectCodes.has(statusCode) || (getMethodRedirectCodes.has(statusCode) && (options.method === 'GET' || options.method === 'HEAD'))) {\n\t\t\t\t\t\tresponse.resume(); // We're being redirected, we don't care about the response.\n\n\t\t\t\t\t\tif (statusCode === 303) {\n\t\t\t\t\t\t\t// Server responded with \"see other\", indicating that the resource exists at another location,\n\t\t\t\t\t\t\t// and the client should request it from that location via GET or HEAD.\n\t\t\t\t\t\t\toptions.method = 'GET';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (redirects.length >= 10) {\n\t\t\t\t\t\t\tthrow new MaxRedirectsError(statusCode, redirects, options);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604\n\t\t\t\t\t\tconst redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n\t\t\t\t\t\tconst redirectURL = new URL(redirectBuffer, currentUrl);\n\t\t\t\t\t\tredirectString = redirectURL.toString();\n\n\t\t\t\t\t\tredirects.push(redirectString);\n\n\t\t\t\t\t\tconst redirectOptions = {\n\t\t\t\t\t\t\t...options,\n\t\t\t\t\t\t\t...urlToOptions(redirectURL)\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor (const hook of options.hooks.beforeRedirect) {\n\t\t\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\t\t\tawait hook(redirectOptions);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\temitter.emit('redirect', response, redirectOptions);\n\n\t\t\t\t\t\tawait get(redirectOptions);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tgetResponse(response, options, emitter);\n\t\t\t} catch (error) {\n\t\t\t\temitError(error);\n\t\t\t}\n\t\t};\n\n\t\tconst handleRequest = request => {\n\t\t\tif (shouldAbort) {\n\t\t\t\trequest.once('error', () => {});\n\t\t\t\trequest.abort();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcurrentRequest = request;\n\n\t\t\trequest.once('error', error => {\n\t\t\t\tif (request.aborted) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (error instanceof timedOut.TimeoutError) {\n\t\t\t\t\terror = new TimeoutError(error, options);\n\t\t\t\t} else {\n\t\t\t\t\terror = new RequestError(error, options);\n\t\t\t\t}\n\n\t\t\t\tif (emitter.retry(error) === false) {\n\t\t\t\t\temitError(error);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\ttimings = timer(request);\n\n\t\t\tprogress.upload(request, emitter, uploadBodySize);\n\n\t\t\tif (options.gotTimeout) {\n\t\t\t\ttimedOut(request, options.gotTimeout, options);\n\t\t\t}\n\n\t\t\temitter.emit('request', request);\n\n\t\t\tconst uploadComplete = () => {\n\t\t\t\trequest.emit('upload-complete');\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tif (is.nodeStream(options.body)) {\n\t\t\t\t\toptions.body.once('end', uploadComplete);\n\t\t\t\t\toptions.body.pipe(request);\n\t\t\t\t\toptions.body = undefined;\n\t\t\t\t} else if (options.body) {\n\t\t\t\t\trequest.end(options.body, uploadComplete);\n\t\t\t\t} else if (input && (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH')) {\n\t\t\t\t\tinput.once('end', uploadComplete);\n\t\t\t\t\tinput.pipe(request);\n\t\t\t\t} else {\n\t\t\t\t\trequest.end(uploadComplete);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\temitError(new RequestError(error, options));\n\t\t\t}\n\t\t};\n\n\t\tif (options.cache) {\n\t\t\tconst cacheableRequest = new CacheableRequest(fn.request, options.cache);\n\t\t\tconst cacheRequest = cacheableRequest(options, handleResponse);\n\n\t\t\tcacheRequest.once('error', error => {\n\t\t\t\tif (error instanceof CacheableRequest.RequestError) {\n\t\t\t\t\temitError(new RequestError(error, options));\n\t\t\t\t} else {\n\t\t\t\t\temitError(new CacheError(error, options));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tcacheRequest.once('request', handleRequest);\n\t\t} else {\n\t\t\t// Catches errors thrown by calling fn.request(...)\n\t\t\ttry {\n\t\t\t\thandleRequest(fn.request(options, handleResponse));\n\t\t\t} catch (error) {\n\t\t\t\temitError(new RequestError(error, options));\n\t\t\t}\n\t\t}\n\t};\n\n\temitter.retry = error => {\n\t\tlet backoff;\n\n\t\ttry {\n\t\t\tbackoff = options.retry.retries(++retryCount, error);\n\t\t} catch (error2) {\n\t\t\temitError(error2);\n\t\t\treturn;\n\t\t}\n\n\t\tif (backoff) {\n\t\t\tconst retry = async options => {\n\t\t\t\ttry {\n\t\t\t\t\tfor (const hook of options.hooks.beforeRetry) {\n\t\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\t\tawait hook(options, error, retryCount);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait get(options);\n\t\t\t\t} catch (error) {\n\t\t\t\t\temitError(error);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tsetTimeout(retry, backoff, {...options, forceRefresh: true});\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\temitter.abort = () => {\n\t\tif (currentRequest) {\n\t\t\tcurrentRequest.once('error', () => {});\n\t\t\tcurrentRequest.abort();\n\t\t} else {\n\t\t\tshouldAbort = true;\n\t\t}\n\t};\n\n\tsetImmediate(async () => {\n\t\ttry {\n\t\t\t// Convert buffer to stream to receive upload progress events (#322)\n\t\t\tconst {body} = options;\n\t\t\tif (is.buffer(body)) {\n\t\t\t\toptions.body = toReadableStream(body);\n\t\t\t\tuploadBodySize = body.length;\n\t\t\t} else {\n\t\t\t\tuploadBodySize = await getBodySize(options);\n\t\t\t}\n\n\t\t\tif (is.undefined(options.headers['content-length']) && is.undefined(options.headers['transfer-encoding'])) {\n\t\t\t\tif ((uploadBodySize > 0 || options.method === 'PUT') && !is.null(uploadBodySize)) {\n\t\t\t\t\toptions.headers['content-length'] = uploadBodySize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const hook of options.hooks.beforeRequest) {\n\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\tawait hook(options);\n\t\t\t}\n\n\t\t\trequestUrl = options.href || (new URL(options.path, urlLib.format(options))).toString();\n\n\t\t\tawait get(options);\n\t\t} catch (error) {\n\t\t\temitError(error);\n\t\t}\n\t});\n\n\treturn emitter;\n};\n"]},"metadata":{},"sourceType":"script"}