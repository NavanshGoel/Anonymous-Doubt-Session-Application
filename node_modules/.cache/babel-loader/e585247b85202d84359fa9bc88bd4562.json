{"ast":null,"code":"'use strict';\n\nconst {\n  Transform\n} = require('stream');\n\nmodule.exports = {\n  download(response, emitter, downloadBodySize) {\n    let downloaded = 0;\n    return new Transform({\n      transform(chunk, encoding, callback) {\n        downloaded += chunk.length;\n        const percent = downloadBodySize ? downloaded / downloadBodySize : 0; // Let `flush()` be responsible for emitting the last event\n\n        if (percent < 1) {\n          emitter.emit('downloadProgress', {\n            percent,\n            transferred: downloaded,\n            total: downloadBodySize\n          });\n        }\n\n        callback(null, chunk);\n      },\n\n      flush(callback) {\n        emitter.emit('downloadProgress', {\n          percent: 1,\n          transferred: downloaded,\n          total: downloadBodySize\n        });\n        callback();\n      }\n\n    });\n  },\n\n  upload(request, emitter, uploadBodySize) {\n    const uploadEventFrequency = 150;\n    let uploaded = 0;\n    let progressInterval;\n    emitter.emit('uploadProgress', {\n      percent: 0,\n      transferred: 0,\n      total: uploadBodySize\n    });\n    request.once('error', () => {\n      clearInterval(progressInterval);\n    });\n    request.once('response', () => {\n      clearInterval(progressInterval);\n      emitter.emit('uploadProgress', {\n        percent: 1,\n        transferred: uploaded,\n        total: uploadBodySize\n      });\n    });\n    request.once('socket', socket => {\n      const onSocketConnect = () => {\n        progressInterval = setInterval(() => {\n          const lastUploaded = uploaded;\n          /* istanbul ignore next: see #490 (occurs randomly!) */\n\n          const headersSize = request._header ? Buffer.byteLength(request._header) : 0;\n          uploaded = socket.bytesWritten - headersSize; // Don't emit events with unchanged progress and\n          // prevent last event from being emitted, because\n          // it's emitted when `response` is emitted\n\n          if (uploaded === lastUploaded || uploaded === uploadBodySize) {\n            return;\n          }\n\n          emitter.emit('uploadProgress', {\n            percent: uploadBodySize ? uploaded / uploadBodySize : 0,\n            transferred: uploaded,\n            total: uploadBodySize\n          });\n        }, uploadEventFrequency);\n      };\n      /* istanbul ignore next: hard to test */\n\n\n      if (socket.connecting) {\n        socket.once('connect', onSocketConnect);\n      } else if (socket.writable) {\n        // The socket is being reused from pool,\n        // so the connect event will not be emitted\n        onSocketConnect();\n      }\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/kanavmittal/Downloads/Anonymous-Doubt-Session-Application-Ashank-App/node_modules/got/source/progress.js"],"names":["Transform","require","module","exports","download","response","emitter","downloadBodySize","downloaded","transform","chunk","encoding","callback","length","percent","emit","transferred","total","flush","upload","request","uploadBodySize","uploadEventFrequency","uploaded","progressInterval","once","clearInterval","socket","onSocketConnect","setInterval","lastUploaded","headersSize","_header","Buffer","byteLength","bytesWritten","connecting","writable"],"mappings":"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","sourcesContent":["'use strict';\nconst {Transform} = require('stream');\n\nmodule.exports = {\n\tdownload(response, emitter, downloadBodySize) {\n\t\tlet downloaded = 0;\n\n\t\treturn new Transform({\n\t\t\ttransform(chunk, encoding, callback) {\n\t\t\t\tdownloaded += chunk.length;\n\n\t\t\t\tconst percent = downloadBodySize ? downloaded / downloadBodySize : 0;\n\n\t\t\t\t// Let `flush()` be responsible for emitting the last event\n\t\t\t\tif (percent < 1) {\n\t\t\t\t\temitter.emit('downloadProgress', {\n\t\t\t\t\t\tpercent,\n\t\t\t\t\t\ttransferred: downloaded,\n\t\t\t\t\t\ttotal: downloadBodySize\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tcallback(null, chunk);\n\t\t\t},\n\n\t\t\tflush(callback) {\n\t\t\t\temitter.emit('downloadProgress', {\n\t\t\t\t\tpercent: 1,\n\t\t\t\t\ttransferred: downloaded,\n\t\t\t\t\ttotal: downloadBodySize\n\t\t\t\t});\n\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t},\n\n\tupload(request, emitter, uploadBodySize) {\n\t\tconst uploadEventFrequency = 150;\n\t\tlet uploaded = 0;\n\t\tlet progressInterval;\n\n\t\temitter.emit('uploadProgress', {\n\t\t\tpercent: 0,\n\t\t\ttransferred: 0,\n\t\t\ttotal: uploadBodySize\n\t\t});\n\n\t\trequest.once('error', () => {\n\t\t\tclearInterval(progressInterval);\n\t\t});\n\n\t\trequest.once('response', () => {\n\t\t\tclearInterval(progressInterval);\n\n\t\t\temitter.emit('uploadProgress', {\n\t\t\t\tpercent: 1,\n\t\t\t\ttransferred: uploaded,\n\t\t\t\ttotal: uploadBodySize\n\t\t\t});\n\t\t});\n\n\t\trequest.once('socket', socket => {\n\t\t\tconst onSocketConnect = () => {\n\t\t\t\tprogressInterval = setInterval(() => {\n\t\t\t\t\tconst lastUploaded = uploaded;\n\t\t\t\t\t/* istanbul ignore next: see #490 (occurs randomly!) */\n\t\t\t\t\tconst headersSize = request._header ? Buffer.byteLength(request._header) : 0;\n\t\t\t\t\tuploaded = socket.bytesWritten - headersSize;\n\n\t\t\t\t\t// Don't emit events with unchanged progress and\n\t\t\t\t\t// prevent last event from being emitted, because\n\t\t\t\t\t// it's emitted when `response` is emitted\n\t\t\t\t\tif (uploaded === lastUploaded || uploaded === uploadBodySize) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\temitter.emit('uploadProgress', {\n\t\t\t\t\t\tpercent: uploadBodySize ? uploaded / uploadBodySize : 0,\n\t\t\t\t\t\ttransferred: uploaded,\n\t\t\t\t\t\ttotal: uploadBodySize\n\t\t\t\t\t});\n\t\t\t\t}, uploadEventFrequency);\n\t\t\t};\n\n\t\t\t/* istanbul ignore next: hard to test */\n\t\t\tif (socket.connecting) {\n\t\t\t\tsocket.once('connect', onSocketConnect);\n\t\t\t} else if (socket.writable) {\n\t\t\t\t// The socket is being reused from pool,\n\t\t\t\t// so the connect event will not be emitted\n\t\t\t\tonSocketConnect();\n\t\t\t}\n\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}