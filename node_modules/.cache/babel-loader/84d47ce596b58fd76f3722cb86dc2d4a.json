{"ast":null,"code":"'use strict';\n\nconst {\n  PassThrough\n} = require('stream');\n\nconst duplexer3 = require('duplexer3');\n\nconst requestAsEventEmitter = require('./request-as-event-emitter');\n\nconst {\n  HTTPError,\n  ReadError\n} = require('./errors');\n\nmodule.exports = options => {\n  const input = new PassThrough();\n  const output = new PassThrough();\n  const proxy = duplexer3(input, output);\n  const piped = new Set();\n  let isFinished = false;\n\n  options.retry.retries = () => 0;\n\n  if (options.body) {\n    proxy.write = () => {\n      throw new Error('Got\\'s stream is not writable when the `body` option is used');\n    };\n  }\n\n  const emitter = requestAsEventEmitter(options, input); // Cancels the request\n\n  proxy._destroy = emitter.abort;\n  emitter.on('response', response => {\n    const {\n      statusCode\n    } = response;\n    response.on('error', error => {\n      proxy.emit('error', new ReadError(error, options));\n    });\n\n    if (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {\n      proxy.emit('error', new HTTPError(response, options), null, response);\n      return;\n    }\n\n    isFinished = true;\n    response.pipe(output);\n\n    for (const destination of piped) {\n      if (destination.headersSent) {\n        continue;\n      }\n\n      for (const [key, value] of Object.entries(response.headers)) {\n        // Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.\n        // It's not possible to decompress already decompressed data, is it?\n        const allowed = options.decompress ? key !== 'content-encoding' : true;\n\n        if (allowed) {\n          destination.setHeader(key, value);\n        }\n      }\n\n      destination.statusCode = response.statusCode;\n    }\n\n    proxy.emit('response', response);\n  });\n  ['error', 'request', 'redirect', 'uploadProgress', 'downloadProgress'].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));\n  const pipe = proxy.pipe.bind(proxy);\n  const unpipe = proxy.unpipe.bind(proxy);\n\n  proxy.pipe = (destination, options) => {\n    if (isFinished) {\n      throw new Error('Failed to pipe. The response has been emitted already.');\n    }\n\n    const result = pipe(destination, options);\n\n    if (Reflect.has(destination, 'setHeader')) {\n      piped.add(destination);\n    }\n\n    return result;\n  };\n\n  proxy.unpipe = stream => {\n    piped.delete(stream);\n    return unpipe(stream);\n  };\n\n  return proxy;\n};","map":{"version":3,"sources":["/Users/kanavmittal/Downloads/Anonymous-Doubt-Session-Application-Ashank-App/node_modules/got/source/as-stream.js"],"names":["PassThrough","require","duplexer3","requestAsEventEmitter","HTTPError","ReadError","module","exports","options","input","output","proxy","piped","Set","isFinished","retry","retries","body","write","Error","emitter","_destroy","abort","on","response","statusCode","error","emit","throwHttpErrors","pipe","destination","headersSent","key","value","Object","entries","headers","allowed","decompress","setHeader","forEach","event","args","bind","unpipe","result","Reflect","has","add","stream","delete"],"mappings":"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","sourcesContent":["'use strict';\nconst {PassThrough} = require('stream');\nconst duplexer3 = require('duplexer3');\nconst requestAsEventEmitter = require('./request-as-event-emitter');\nconst {HTTPError, ReadError} = require('./errors');\n\nmodule.exports = options => {\n\tconst input = new PassThrough();\n\tconst output = new PassThrough();\n\tconst proxy = duplexer3(input, output);\n\tconst piped = new Set();\n\tlet isFinished = false;\n\n\toptions.retry.retries = () => 0;\n\n\tif (options.body) {\n\t\tproxy.write = () => {\n\t\t\tthrow new Error('Got\\'s stream is not writable when the `body` option is used');\n\t\t};\n\t}\n\n\tconst emitter = requestAsEventEmitter(options, input);\n\n\t// Cancels the request\n\tproxy._destroy = emitter.abort;\n\n\temitter.on('response', response => {\n\t\tconst {statusCode} = response;\n\n\t\tresponse.on('error', error => {\n\t\t\tproxy.emit('error', new ReadError(error, options));\n\t\t});\n\n\t\tif (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {\n\t\t\tproxy.emit('error', new HTTPError(response, options), null, response);\n\t\t\treturn;\n\t\t}\n\n\t\tisFinished = true;\n\n\t\tresponse.pipe(output);\n\n\t\tfor (const destination of piped) {\n\t\t\tif (destination.headersSent) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (const [key, value] of Object.entries(response.headers)) {\n\t\t\t\t// Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.\n\t\t\t\t// It's not possible to decompress already decompressed data, is it?\n\t\t\t\tconst allowed = options.decompress ? key !== 'content-encoding' : true;\n\t\t\t\tif (allowed) {\n\t\t\t\t\tdestination.setHeader(key, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdestination.statusCode = response.statusCode;\n\t\t}\n\n\t\tproxy.emit('response', response);\n\t});\n\n\t[\n\t\t'error',\n\t\t'request',\n\t\t'redirect',\n\t\t'uploadProgress',\n\t\t'downloadProgress'\n\t].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));\n\n\tconst pipe = proxy.pipe.bind(proxy);\n\tconst unpipe = proxy.unpipe.bind(proxy);\n\tproxy.pipe = (destination, options) => {\n\t\tif (isFinished) {\n\t\t\tthrow new Error('Failed to pipe. The response has been emitted already.');\n\t\t}\n\n\t\tconst result = pipe(destination, options);\n\n\t\tif (Reflect.has(destination, 'setHeader')) {\n\t\t\tpiped.add(destination);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tproxy.unpipe = stream => {\n\t\tpiped.delete(stream);\n\t\treturn unpipe(stream);\n\t};\n\n\treturn proxy;\n};\n"]},"metadata":{},"sourceType":"script"}