{"ast":null,"code":"/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\"use strict\";\n\nconst {\n  fromCallback\n} = require(\"universalify\");\n\nconst Store = require(\"./store\").Store;\n\nconst permuteDomain = require(\"./permuteDomain\").permuteDomain;\n\nconst pathMatch = require(\"./pathMatch\").pathMatch;\n\nconst util = require(\"util\");\n\nclass MemoryCookieStore extends Store {\n  constructor() {\n    super();\n    this.synchronous = true;\n    this.idx = {};\n\n    if (util.inspect.custom) {\n      this[util.inspect.custom] = this.inspect;\n    }\n  }\n\n  inspect() {\n    return `{ idx: ${util.inspect(this.idx, false, 2)} }`;\n  }\n\n  findCookie(domain, path, key, cb) {\n    if (!this.idx[domain]) {\n      return cb(null, undefined);\n    }\n\n    if (!this.idx[domain][path]) {\n      return cb(null, undefined);\n    }\n\n    return cb(null, this.idx[domain][path][key] || null);\n  }\n\n  findCookies(domain, path, allowSpecialUseDomain, cb) {\n    const results = [];\n\n    if (typeof allowSpecialUseDomain === \"function\") {\n      cb = allowSpecialUseDomain;\n      allowSpecialUseDomain = false;\n    }\n\n    if (!domain) {\n      return cb(null, []);\n    }\n\n    let pathMatcher;\n\n    if (!path) {\n      // null means \"all paths\"\n      pathMatcher = function matchAll(domainIndex) {\n        for (const curPath in domainIndex) {\n          const pathIndex = domainIndex[curPath];\n\n          for (const key in pathIndex) {\n            results.push(pathIndex[key]);\n          }\n        }\n      };\n    } else {\n      pathMatcher = function matchRFC(domainIndex) {\n        //NOTE: we should use path-match algorithm from S5.1.4 here\n        //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n        Object.keys(domainIndex).forEach(cookiePath => {\n          if (pathMatch(path, cookiePath)) {\n            const pathIndex = domainIndex[cookiePath];\n\n            for (const key in pathIndex) {\n              results.push(pathIndex[key]);\n            }\n          }\n        });\n      };\n    }\n\n    const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];\n    const idx = this.idx;\n    domains.forEach(curDomain => {\n      const domainIndex = idx[curDomain];\n\n      if (!domainIndex) {\n        return;\n      }\n\n      pathMatcher(domainIndex);\n    });\n    cb(null, results);\n  }\n\n  putCookie(cookie, cb) {\n    if (!this.idx[cookie.domain]) {\n      this.idx[cookie.domain] = {};\n    }\n\n    if (!this.idx[cookie.domain][cookie.path]) {\n      this.idx[cookie.domain][cookie.path] = {};\n    }\n\n    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;\n    cb(null);\n  }\n\n  updateCookie(oldCookie, newCookie, cb) {\n    // updateCookie() may avoid updating cookies that are identical.  For example,\n    // lastAccessed may not be important to some stores and an equality\n    // comparison could exclude that field.\n    this.putCookie(newCookie, cb);\n  }\n\n  removeCookie(domain, path, key, cb) {\n    if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {\n      delete this.idx[domain][path][key];\n    }\n\n    cb(null);\n  }\n\n  removeCookies(domain, path, cb) {\n    if (this.idx[domain]) {\n      if (path) {\n        delete this.idx[domain][path];\n      } else {\n        delete this.idx[domain];\n      }\n    }\n\n    return cb(null);\n  }\n\n  removeAllCookies(cb) {\n    this.idx = {};\n    return cb(null);\n  }\n\n  getAllCookies(cb) {\n    const cookies = [];\n    const idx = this.idx;\n    const domains = Object.keys(idx);\n    domains.forEach(domain => {\n      const paths = Object.keys(idx[domain]);\n      paths.forEach(path => {\n        const keys = Object.keys(idx[domain][path]);\n        keys.forEach(key => {\n          if (key !== null) {\n            cookies.push(idx[domain][path][key]);\n          }\n        });\n      });\n    }); // Sort by creationIndex so deserializing retains the creation order.\n    // When implementing your own store, this SHOULD retain the order too\n\n    cookies.sort((a, b) => {\n      return (a.creationIndex || 0) - (b.creationIndex || 0);\n    });\n    cb(null, cookies);\n  }\n\n}\n\n[\"findCookie\", \"findCookies\", \"putCookie\", \"updateCookie\", \"removeCookie\", \"removeCookies\", \"removeAllCookies\", \"getAllCookies\"].forEach(name => {\n  MemoryCookieStore[name] = fromCallback(MemoryCookieStore.prototype[name]);\n});\nexports.MemoryCookieStore = MemoryCookieStore;","map":{"version":3,"sources":["/Users/kanavmittal/Downloads/Anonymous-Doubt-Session-Application-Ashank-App/node_modules/tough-cookie/lib/memstore.js"],"names":["fromCallback","require","Store","permuteDomain","pathMatch","util","MemoryCookieStore","constructor","synchronous","idx","inspect","custom","findCookie","domain","path","key","cb","undefined","findCookies","allowSpecialUseDomain","results","pathMatcher","matchAll","domainIndex","curPath","pathIndex","push","matchRFC","Object","keys","forEach","cookiePath","domains","curDomain","putCookie","cookie","updateCookie","oldCookie","newCookie","removeCookie","removeCookies","removeAllCookies","getAllCookies","cookies","paths","sort","a","b","creationIndex","name","prototype","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAM;AAAEA,EAAAA;AAAF,IAAmBC,OAAO,CAAC,cAAD,CAAhC;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAD,CAAP,CAAmBC,KAAjC;;AACA,MAAMC,aAAa,GAAGF,OAAO,CAAC,iBAAD,CAAP,CAA2BE,aAAjD;;AACA,MAAMC,SAAS,GAAGH,OAAO,CAAC,aAAD,CAAP,CAAuBG,SAAzC;;AACA,MAAMC,IAAI,GAAGJ,OAAO,CAAC,MAAD,CAApB;;AAEA,MAAMK,iBAAN,SAAgCJ,KAAhC,CAAsC;AACpCK,EAAAA,WAAW,GAAG;AACZ;AACA,SAAKC,WAAL,GAAmB,IAAnB;AACA,SAAKC,GAAL,GAAW,EAAX;;AACA,QAAIJ,IAAI,CAACK,OAAL,CAAaC,MAAjB,EAAyB;AACvB,WAAKN,IAAI,CAACK,OAAL,CAAaC,MAAlB,IAA4B,KAAKD,OAAjC;AACD;AACF;;AAEDA,EAAAA,OAAO,GAAG;AACR,WAAQ,UAASL,IAAI,CAACK,OAAL,CAAa,KAAKD,GAAlB,EAAuB,KAAvB,EAA8B,CAA9B,CAAiC,IAAlD;AACD;;AAEDG,EAAAA,UAAU,CAACC,MAAD,EAASC,IAAT,EAAeC,GAAf,EAAoBC,EAApB,EAAwB;AAChC,QAAI,CAAC,KAAKP,GAAL,CAASI,MAAT,CAAL,EAAuB;AACrB,aAAOG,EAAE,CAAC,IAAD,EAAOC,SAAP,CAAT;AACD;;AACD,QAAI,CAAC,KAAKR,GAAL,CAASI,MAAT,EAAiBC,IAAjB,CAAL,EAA6B;AAC3B,aAAOE,EAAE,CAAC,IAAD,EAAOC,SAAP,CAAT;AACD;;AACD,WAAOD,EAAE,CAAC,IAAD,EAAO,KAAKP,GAAL,CAASI,MAAT,EAAiBC,IAAjB,EAAuBC,GAAvB,KAA+B,IAAtC,CAAT;AACD;;AACDG,EAAAA,WAAW,CAACL,MAAD,EAASC,IAAT,EAAeK,qBAAf,EAAsCH,EAAtC,EAA0C;AACnD,UAAMI,OAAO,GAAG,EAAhB;;AACA,QAAI,OAAOD,qBAAP,KAAiC,UAArC,EAAiD;AAC/CH,MAAAA,EAAE,GAAGG,qBAAL;AACAA,MAAAA,qBAAqB,GAAG,KAAxB;AACD;;AACD,QAAI,CAACN,MAAL,EAAa;AACX,aAAOG,EAAE,CAAC,IAAD,EAAO,EAAP,CAAT;AACD;;AAED,QAAIK,WAAJ;;AACA,QAAI,CAACP,IAAL,EAAW;AACT;AACAO,MAAAA,WAAW,GAAG,SAASC,QAAT,CAAkBC,WAAlB,EAA+B;AAC3C,aAAK,MAAMC,OAAX,IAAsBD,WAAtB,EAAmC;AACjC,gBAAME,SAAS,GAAGF,WAAW,CAACC,OAAD,CAA7B;;AACA,eAAK,MAAMT,GAAX,IAAkBU,SAAlB,EAA6B;AAC3BL,YAAAA,OAAO,CAACM,IAAR,CAAaD,SAAS,CAACV,GAAD,CAAtB;AACD;AACF;AACF,OAPD;AAQD,KAVD,MAUO;AACLM,MAAAA,WAAW,GAAG,SAASM,QAAT,CAAkBJ,WAAlB,EAA+B;AAC3C;AACA;AACAK,QAAAA,MAAM,CAACC,IAAP,CAAYN,WAAZ,EAAyBO,OAAzB,CAAiCC,UAAU,IAAI;AAC7C,cAAI3B,SAAS,CAACU,IAAD,EAAOiB,UAAP,CAAb,EAAiC;AAC/B,kBAAMN,SAAS,GAAGF,WAAW,CAACQ,UAAD,CAA7B;;AACA,iBAAK,MAAMhB,GAAX,IAAkBU,SAAlB,EAA6B;AAC3BL,cAAAA,OAAO,CAACM,IAAR,CAAaD,SAAS,CAACV,GAAD,CAAtB;AACD;AACF;AACF,SAPD;AAQD,OAXD;AAYD;;AAED,UAAMiB,OAAO,GAAG7B,aAAa,CAACU,MAAD,EAASM,qBAAT,CAAb,IAAgD,CAACN,MAAD,CAAhE;AACA,UAAMJ,GAAG,GAAG,KAAKA,GAAjB;AACAuB,IAAAA,OAAO,CAACF,OAAR,CAAgBG,SAAS,IAAI;AAC3B,YAAMV,WAAW,GAAGd,GAAG,CAACwB,SAAD,CAAvB;;AACA,UAAI,CAACV,WAAL,EAAkB;AAChB;AACD;;AACDF,MAAAA,WAAW,CAACE,WAAD,CAAX;AACD,KAND;AAQAP,IAAAA,EAAE,CAAC,IAAD,EAAOI,OAAP,CAAF;AACD;;AAEDc,EAAAA,SAAS,CAACC,MAAD,EAASnB,EAAT,EAAa;AACpB,QAAI,CAAC,KAAKP,GAAL,CAAS0B,MAAM,CAACtB,MAAhB,CAAL,EAA8B;AAC5B,WAAKJ,GAAL,CAAS0B,MAAM,CAACtB,MAAhB,IAA0B,EAA1B;AACD;;AACD,QAAI,CAAC,KAAKJ,GAAL,CAAS0B,MAAM,CAACtB,MAAhB,EAAwBsB,MAAM,CAACrB,IAA/B,CAAL,EAA2C;AACzC,WAAKL,GAAL,CAAS0B,MAAM,CAACtB,MAAhB,EAAwBsB,MAAM,CAACrB,IAA/B,IAAuC,EAAvC;AACD;;AACD,SAAKL,GAAL,CAAS0B,MAAM,CAACtB,MAAhB,EAAwBsB,MAAM,CAACrB,IAA/B,EAAqCqB,MAAM,CAACpB,GAA5C,IAAmDoB,MAAnD;AACAnB,IAAAA,EAAE,CAAC,IAAD,CAAF;AACD;;AACDoB,EAAAA,YAAY,CAACC,SAAD,EAAYC,SAAZ,EAAuBtB,EAAvB,EAA2B;AACrC;AACA;AACA;AACA,SAAKkB,SAAL,CAAeI,SAAf,EAA0BtB,EAA1B;AACD;;AACDuB,EAAAA,YAAY,CAAC1B,MAAD,EAASC,IAAT,EAAeC,GAAf,EAAoBC,EAApB,EAAwB;AAClC,QACE,KAAKP,GAAL,CAASI,MAAT,KACA,KAAKJ,GAAL,CAASI,MAAT,EAAiBC,IAAjB,CADA,IAEA,KAAKL,GAAL,CAASI,MAAT,EAAiBC,IAAjB,EAAuBC,GAAvB,CAHF,EAIE;AACA,aAAO,KAAKN,GAAL,CAASI,MAAT,EAAiBC,IAAjB,EAAuBC,GAAvB,CAAP;AACD;;AACDC,IAAAA,EAAE,CAAC,IAAD,CAAF;AACD;;AACDwB,EAAAA,aAAa,CAAC3B,MAAD,EAASC,IAAT,EAAeE,EAAf,EAAmB;AAC9B,QAAI,KAAKP,GAAL,CAASI,MAAT,CAAJ,EAAsB;AACpB,UAAIC,IAAJ,EAAU;AACR,eAAO,KAAKL,GAAL,CAASI,MAAT,EAAiBC,IAAjB,CAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAKL,GAAL,CAASI,MAAT,CAAP;AACD;AACF;;AACD,WAAOG,EAAE,CAAC,IAAD,CAAT;AACD;;AACDyB,EAAAA,gBAAgB,CAACzB,EAAD,EAAK;AACnB,SAAKP,GAAL,GAAW,EAAX;AACA,WAAOO,EAAE,CAAC,IAAD,CAAT;AACD;;AACD0B,EAAAA,aAAa,CAAC1B,EAAD,EAAK;AAChB,UAAM2B,OAAO,GAAG,EAAhB;AACA,UAAMlC,GAAG,GAAG,KAAKA,GAAjB;AAEA,UAAMuB,OAAO,GAAGJ,MAAM,CAACC,IAAP,CAAYpB,GAAZ,CAAhB;AACAuB,IAAAA,OAAO,CAACF,OAAR,CAAgBjB,MAAM,IAAI;AACxB,YAAM+B,KAAK,GAAGhB,MAAM,CAACC,IAAP,CAAYpB,GAAG,CAACI,MAAD,CAAf,CAAd;AACA+B,MAAAA,KAAK,CAACd,OAAN,CAAchB,IAAI,IAAI;AACpB,cAAMe,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAYpB,GAAG,CAACI,MAAD,CAAH,CAAYC,IAAZ,CAAZ,CAAb;AACAe,QAAAA,IAAI,CAACC,OAAL,CAAaf,GAAG,IAAI;AAClB,cAAIA,GAAG,KAAK,IAAZ,EAAkB;AAChB4B,YAAAA,OAAO,CAACjB,IAAR,CAAajB,GAAG,CAACI,MAAD,CAAH,CAAYC,IAAZ,EAAkBC,GAAlB,CAAb;AACD;AACF,SAJD;AAKD,OAPD;AAQD,KAVD,EALgB,CAiBhB;AACA;;AACA4B,IAAAA,OAAO,CAACE,IAAR,CAAa,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACrB,aAAO,CAACD,CAAC,CAACE,aAAF,IAAmB,CAApB,KAA0BD,CAAC,CAACC,aAAF,IAAmB,CAA7C,CAAP;AACD,KAFD;AAIAhC,IAAAA,EAAE,CAAC,IAAD,EAAO2B,OAAP,CAAF;AACD;;AAxImC;;AA2ItC,CACE,YADF,EAEE,aAFF,EAGE,WAHF,EAIE,cAJF,EAKE,cALF,EAME,eANF,EAOE,kBAPF,EAQE,eARF,EASEb,OATF,CASUmB,IAAI,IAAI;AAChB3C,EAAAA,iBAAiB,CAAC2C,IAAD,CAAjB,GAA0BjD,YAAY,CAACM,iBAAiB,CAAC4C,SAAlB,CAA4BD,IAA5B,CAAD,CAAtC;AACD,CAXD;AAaAE,OAAO,CAAC7C,iBAAR,GAA4BA,iBAA5B","sourcesContent":["/*!\n * Copyright (c) 2015, Salesforce.com, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of Salesforce.com nor the names of its contributors may\n * be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\"use strict\";\nconst { fromCallback } = require(\"universalify\");\nconst Store = require(\"./store\").Store;\nconst permuteDomain = require(\"./permuteDomain\").permuteDomain;\nconst pathMatch = require(\"./pathMatch\").pathMatch;\nconst util = require(\"util\");\n\nclass MemoryCookieStore extends Store {\n  constructor() {\n    super();\n    this.synchronous = true;\n    this.idx = {};\n    if (util.inspect.custom) {\n      this[util.inspect.custom] = this.inspect;\n    }\n  }\n\n  inspect() {\n    return `{ idx: ${util.inspect(this.idx, false, 2)} }`;\n  }\n\n  findCookie(domain, path, key, cb) {\n    if (!this.idx[domain]) {\n      return cb(null, undefined);\n    }\n    if (!this.idx[domain][path]) {\n      return cb(null, undefined);\n    }\n    return cb(null, this.idx[domain][path][key] || null);\n  }\n  findCookies(domain, path, allowSpecialUseDomain, cb) {\n    const results = [];\n    if (typeof allowSpecialUseDomain === \"function\") {\n      cb = allowSpecialUseDomain;\n      allowSpecialUseDomain = false;\n    }\n    if (!domain) {\n      return cb(null, []);\n    }\n\n    let pathMatcher;\n    if (!path) {\n      // null means \"all paths\"\n      pathMatcher = function matchAll(domainIndex) {\n        for (const curPath in domainIndex) {\n          const pathIndex = domainIndex[curPath];\n          for (const key in pathIndex) {\n            results.push(pathIndex[key]);\n          }\n        }\n      };\n    } else {\n      pathMatcher = function matchRFC(domainIndex) {\n        //NOTE: we should use path-match algorithm from S5.1.4 here\n        //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)\n        Object.keys(domainIndex).forEach(cookiePath => {\n          if (pathMatch(path, cookiePath)) {\n            const pathIndex = domainIndex[cookiePath];\n            for (const key in pathIndex) {\n              results.push(pathIndex[key]);\n            }\n          }\n        });\n      };\n    }\n\n    const domains = permuteDomain(domain, allowSpecialUseDomain) || [domain];\n    const idx = this.idx;\n    domains.forEach(curDomain => {\n      const domainIndex = idx[curDomain];\n      if (!domainIndex) {\n        return;\n      }\n      pathMatcher(domainIndex);\n    });\n\n    cb(null, results);\n  }\n\n  putCookie(cookie, cb) {\n    if (!this.idx[cookie.domain]) {\n      this.idx[cookie.domain] = {};\n    }\n    if (!this.idx[cookie.domain][cookie.path]) {\n      this.idx[cookie.domain][cookie.path] = {};\n    }\n    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;\n    cb(null);\n  }\n  updateCookie(oldCookie, newCookie, cb) {\n    // updateCookie() may avoid updating cookies that are identical.  For example,\n    // lastAccessed may not be important to some stores and an equality\n    // comparison could exclude that field.\n    this.putCookie(newCookie, cb);\n  }\n  removeCookie(domain, path, key, cb) {\n    if (\n      this.idx[domain] &&\n      this.idx[domain][path] &&\n      this.idx[domain][path][key]\n    ) {\n      delete this.idx[domain][path][key];\n    }\n    cb(null);\n  }\n  removeCookies(domain, path, cb) {\n    if (this.idx[domain]) {\n      if (path) {\n        delete this.idx[domain][path];\n      } else {\n        delete this.idx[domain];\n      }\n    }\n    return cb(null);\n  }\n  removeAllCookies(cb) {\n    this.idx = {};\n    return cb(null);\n  }\n  getAllCookies(cb) {\n    const cookies = [];\n    const idx = this.idx;\n\n    const domains = Object.keys(idx);\n    domains.forEach(domain => {\n      const paths = Object.keys(idx[domain]);\n      paths.forEach(path => {\n        const keys = Object.keys(idx[domain][path]);\n        keys.forEach(key => {\n          if (key !== null) {\n            cookies.push(idx[domain][path][key]);\n          }\n        });\n      });\n    });\n\n    // Sort by creationIndex so deserializing retains the creation order.\n    // When implementing your own store, this SHOULD retain the order too\n    cookies.sort((a, b) => {\n      return (a.creationIndex || 0) - (b.creationIndex || 0);\n    });\n\n    cb(null, cookies);\n  }\n}\n\n[\n  \"findCookie\",\n  \"findCookies\",\n  \"putCookie\",\n  \"updateCookie\",\n  \"removeCookie\",\n  \"removeCookies\",\n  \"removeAllCookies\",\n  \"getAllCookies\"\n].forEach(name => {\n  MemoryCookieStore[name] = fromCallback(MemoryCookieStore.prototype[name]);\n});\n\nexports.MemoryCookieStore = MemoryCookieStore;\n"]},"metadata":{},"sourceType":"script"}