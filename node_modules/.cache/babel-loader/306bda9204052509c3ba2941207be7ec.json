{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst getStream = require('get-stream');\n\nconst is = require('@sindresorhus/is');\n\nconst PCancelable = require('p-cancelable');\n\nconst requestAsEventEmitter = require('./request-as-event-emitter');\n\nconst {\n  HTTPError,\n  ParseError,\n  ReadError\n} = require('./errors');\n\nconst {\n  options: mergeOptions\n} = require('./merge');\n\nconst {\n  reNormalize\n} = require('./normalize-arguments');\n\nconst asPromise = options => {\n  const proxy = new EventEmitter();\n  const promise = new PCancelable((resolve, reject, onCancel) => {\n    const emitter = requestAsEventEmitter(options);\n    onCancel(emitter.abort);\n    emitter.on('response', async response => {\n      proxy.emit('response', response);\n      const stream = is.null(options.encoding) ? getStream.buffer(response) : getStream(response, options);\n      let data;\n\n      try {\n        data = await stream;\n      } catch (error) {\n        reject(new ReadError(error, options));\n        return;\n      }\n\n      const limitStatusCode = options.followRedirect ? 299 : 399;\n      response.body = data;\n\n      try {\n        for (const [index, hook] of Object.entries(options.hooks.afterResponse)) {\n          // eslint-disable-next-line no-await-in-loop\n          response = await hook(response, updatedOptions => {\n            updatedOptions = reNormalize(mergeOptions(options, { ...updatedOptions,\n              retry: 0,\n              throwHttpErrors: false\n            })); // Remove any further hooks for that request, because we we'll call them anyway.\n            // The loop continues. We don't want duplicates (asPromise recursion).\n\n            updatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n            return asPromise(updatedOptions);\n          });\n        }\n      } catch (error) {\n        reject(error);\n        return;\n      }\n\n      const {\n        statusCode\n      } = response;\n\n      if (options.json && response.body) {\n        try {\n          response.body = JSON.parse(response.body);\n        } catch (error) {\n          if (statusCode >= 200 && statusCode < 300) {\n            const parseError = new ParseError(error, statusCode, options, data);\n            Object.defineProperty(parseError, 'response', {\n              value: response\n            });\n            reject(parseError);\n            return;\n          }\n        }\n      }\n\n      if (statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode)) {\n        const error = new HTTPError(response, options);\n        Object.defineProperty(error, 'response', {\n          value: response\n        });\n\n        if (emitter.retry(error) === false) {\n          if (options.throwHttpErrors) {\n            reject(error);\n            return;\n          }\n\n          resolve(response);\n        }\n\n        return;\n      }\n\n      resolve(response);\n    });\n    emitter.once('error', reject);\n    ['request', 'redirect', 'uploadProgress', 'downloadProgress'].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));\n  });\n\n  promise.on = (name, fn) => {\n    proxy.on(name, fn);\n    return promise;\n  };\n\n  return promise;\n};\n\nmodule.exports = asPromise;","map":{"version":3,"sources":["/Users/kanavmittal/Downloads/Anonymous-Doubt-Session-Application-Ashank-App/node_modules/got/source/as-promise.js"],"names":["EventEmitter","require","getStream","is","PCancelable","requestAsEventEmitter","HTTPError","ParseError","ReadError","options","mergeOptions","reNormalize","asPromise","proxy","promise","resolve","reject","onCancel","emitter","abort","on","response","emit","stream","null","encoding","buffer","data","error","limitStatusCode","followRedirect","body","index","hook","Object","entries","hooks","afterResponse","updatedOptions","retry","throwHttpErrors","slice","statusCode","json","JSON","parse","parseError","defineProperty","value","once","forEach","event","args","name","fn","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst EventEmitter = require('events');\nconst getStream = require('get-stream');\nconst is = require('@sindresorhus/is');\nconst PCancelable = require('p-cancelable');\nconst requestAsEventEmitter = require('./request-as-event-emitter');\nconst {HTTPError, ParseError, ReadError} = require('./errors');\nconst {options: mergeOptions} = require('./merge');\nconst {reNormalize} = require('./normalize-arguments');\n\nconst asPromise = options => {\n\tconst proxy = new EventEmitter();\n\n\tconst promise = new PCancelable((resolve, reject, onCancel) => {\n\t\tconst emitter = requestAsEventEmitter(options);\n\n\t\tonCancel(emitter.abort);\n\n\t\temitter.on('response', async response => {\n\t\t\tproxy.emit('response', response);\n\n\t\t\tconst stream = is.null(options.encoding) ? getStream.buffer(response) : getStream(response, options);\n\n\t\t\tlet data;\n\t\t\ttry {\n\t\t\t\tdata = await stream;\n\t\t\t} catch (error) {\n\t\t\t\treject(new ReadError(error, options));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst limitStatusCode = options.followRedirect ? 299 : 399;\n\n\t\t\tresponse.body = data;\n\n\t\t\ttry {\n\t\t\t\tfor (const [index, hook] of Object.entries(options.hooks.afterResponse)) {\n\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\tresponse = await hook(response, updatedOptions => {\n\t\t\t\t\t\tupdatedOptions = reNormalize(mergeOptions(options, {\n\t\t\t\t\t\t\t...updatedOptions,\n\t\t\t\t\t\t\tretry: 0,\n\t\t\t\t\t\t\tthrowHttpErrors: false\n\t\t\t\t\t\t}));\n\n\t\t\t\t\t\t// Remove any further hooks for that request, because we we'll call them anyway.\n\t\t\t\t\t\t// The loop continues. We don't want duplicates (asPromise recursion).\n\t\t\t\t\t\tupdatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n\n\t\t\t\t\t\treturn asPromise(updatedOptions);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst {statusCode} = response;\n\n\t\t\tif (options.json && response.body) {\n\t\t\t\ttry {\n\t\t\t\t\tresponse.body = JSON.parse(response.body);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (statusCode >= 200 && statusCode < 300) {\n\t\t\t\t\t\tconst parseError = new ParseError(error, statusCode, options, data);\n\t\t\t\t\t\tObject.defineProperty(parseError, 'response', {value: response});\n\t\t\t\t\t\treject(parseError);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode)) {\n\t\t\t\tconst error = new HTTPError(response, options);\n\t\t\t\tObject.defineProperty(error, 'response', {value: response});\n\t\t\t\tif (emitter.retry(error) === false) {\n\t\t\t\t\tif (options.throwHttpErrors) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(response);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve(response);\n\t\t});\n\n\t\temitter.once('error', reject);\n\t\t[\n\t\t\t'request',\n\t\t\t'redirect',\n\t\t\t'uploadProgress',\n\t\t\t'downloadProgress'\n\t\t].forEach(event => emitter.on(event, (...args) => proxy.emit(event, ...args)));\n\t});\n\n\tpromise.on = (name, fn) => {\n\t\tproxy.on(name, fn);\n\t\treturn promise;\n\t};\n\n\treturn promise;\n};\n\nmodule.exports = asPromise;\n"]},"metadata":{},"sourceType":"script"}